---
phase: 05-notification-system
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/api/src/routes/webhooks.ts
  - apps/api/src/services/sms.ts
autonomous: true

must_haves:
  truths:
    - "Twilio SMS status callbacks update NotificationLog.smsStatus"
    - "Webhook responses are immediate (200 OK) before async processing"
    - "Duplicate webhook events are idempotent (no duplicate updates)"
  artifacts:
    - path: "apps/api/src/routes/webhooks.ts"
      provides: "SMS status webhook endpoint"
      contains: "/sms-status"
    - path: "apps/api/src/services/sms.ts"
      provides: "SMS sending with status callback URL"
      contains: "statusCallback"
  key_links:
    - from: "apps/api/src/routes/webhooks.ts"
      to: "prisma.notificationLog"
      via: "status update query"
      pattern: "prisma\\.notificationLog\\.updateMany"
    - from: "apps/api/src/services/sms.ts"
      to: "Twilio API"
      via: "client.messages.create with statusCallback"
      pattern: "statusCallback.*api.*webhooks.*sms-status"
---

<objective>
Add Twilio SMS status webhook endpoint to track actual delivery status (sent, delivered, failed).

Purpose: Enable real-time SMS delivery tracking instead of just API success
Output: Webhook endpoint that updates NotificationLog with Twilio status callbacks
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-notification-system/05-CONTEXT.md
@.planning/phases/05-notification-system/05-RESEARCH.md
@.planning/phases/05-notification-system/05-01-SUMMARY.md
@apps/api/src/routes/webhooks.ts
@apps/api/src/services/sms.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SMS status webhook endpoint</name>
  <files>apps/api/src/routes/webhooks.ts</files>
  <action>
Add a new POST endpoint `/sms-status` to receive Twilio status callbacks.

1. Add import for express.urlencoded at top if not present (Twilio sends form-encoded data)

2. Add the webhook endpoint BEFORE the stripe webhook (since stripe uses raw body):
```typescript
// Twilio SMS status callback webhook
// Twilio sends form-encoded data, NOT JSON
router.post('/sms-status', express.urlencoded({ extended: true }), asyncHandler(async (req: Request, res: Response) => {
  // Respond immediately to avoid Twilio timeout retries
  res.status(200).send('OK');

  // Extract Twilio callback data
  const { MessageSid, MessageStatus, ErrorCode, ErrorMessage } = req.body;

  if (!MessageSid || !MessageStatus) {
    console.warn('[SMS Webhook] Missing MessageSid or MessageStatus');
    return;
  }

  // Map Twilio status to our status
  const statusMap: Record<string, string> = {
    'accepted': 'pending',
    'queued': 'pending',
    'sending': 'pending',
    'sent': 'sent',
    'delivered': 'delivered',
    'undelivered': 'failed',
    'failed': 'failed',
  };

  const smsStatus = statusMap[MessageStatus] || 'unknown';

  try {
    // Update NotificationLog entry by twilioMessageSid
    const result = await prisma.notificationLog.updateMany({
      where: { twilioMessageSid: MessageSid },
      data: {
        smsStatus,
        smsError: ErrorMessage || null,
        smsErrorCode: ErrorCode || null,
        smsDeliveredAt: smsStatus === 'delivered' ? new Date() : undefined,
        // Update overall status if SMS was the only/primary channel
        // Leave as-is if email already succeeded
        updatedAt: new Date(),
      },
    });

    if (result.count === 0) {
      console.log(`[SMS Webhook] No notification found for MessageSid ${MessageSid}`);
    } else {
      console.log(`[SMS Webhook] Updated ${result.count} notification(s) to status: ${smsStatus}`);
    }

    // Handle bounced/invalid numbers - mark client phone as invalid
    if (smsStatus === 'failed' && ErrorCode) {
      // Common invalid number error codes: 21211, 21214, 21217, 21610, 21612
      const invalidNumberCodes = ['21211', '21214', '21217', '21610', '21612'];
      if (invalidNumberCodes.includes(ErrorCode)) {
        const notification = await prisma.notificationLog.findFirst({
          where: { twilioMessageSid: MessageSid },
          select: { clientId: true },
        });

        if (notification) {
          console.log(`[SMS Webhook] Marking client ${notification.clientId} phone as invalid`);
          // Note: We don't have a phoneBounced field yet - just log for now
          // Could add this field in a future update if needed
        }
      }
    }
  } catch (error) {
    console.error('[SMS Webhook] Error processing status callback:', error);
    // Don't throw - we already sent 200 OK
  }
}));
```

3. Important: This endpoint must be BEFORE the Stripe webhook since Stripe needs raw body middleware and this needs urlencoded.
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm exec tsc --noEmit`
Endpoint is accessible: Start API locally, POST to /api/webhooks/sms-status with form data
  </verify>
  <done>
/api/webhooks/sms-status endpoint exists and processes Twilio callbacks.
NotificationLog.smsStatus updates based on Twilio MessageStatus.
Endpoint responds immediately with 200 OK.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SMS service to include status callback URL</name>
  <files>apps/api/src/services/sms.ts</files>
  <action>
Modify the sendSms function to include a statusCallback URL so Twilio sends delivery status updates.

1. Add env import if not already present for API_URL

2. Update the sendSms function to accept an optional twilioMessageSid output and include statusCallback:

```typescript
// Update the interface
interface SendSmsOptions {
  to: string;
  message: string;
}

interface SendSmsResult {
  success: boolean;
  messageSid?: string;  // Return the Twilio MessageSid for tracking
  error?: string;
}

// Update the function signature and implementation
export async function sendSms(options: SendSmsOptions): Promise<SendSmsResult> {
  if (!client || !FROM_NUMBER) {
    console.warn('Twilio not configured - SMS not sent to:', options.to);
    return { success: false, error: 'Twilio not configured' };
  }

  try {
    // Build the status callback URL
    // Use API_URL env var, fallback to production URL
    const apiUrl = env.API_URL || 'https://peacase-api.onrender.com';
    const statusCallback = `${apiUrl}/api/webhooks/sms-status`;

    const message = await client.messages.create({
      body: options.message,
      from: FROM_NUMBER,
      to: formatPhoneNumber(options.to),
      statusCallback,  // Twilio will POST updates to this URL
    });

    console.log(`[SMS] Sent to ${options.to}, MessageSid: ${message.sid}`);
    return { success: true, messageSid: message.sid };
  } catch (error: any) {
    console.error('Twilio SMS error:', error);
    return {
      success: false,
      error: error?.message || 'Unknown error',
    };
  }
}
```

3. Update the bulk SMS function to handle the new return type:

```typescript
export async function sendBulkSms(options: BulkSmsOptions): Promise<{ sent: number; failed: number; sids: string[] }> {
  const results = { sent: 0, failed: 0, sids: [] as string[] };

  for (const phone of options.recipients) {
    const result = await sendSms({ to: phone, message: options.message });
    if (result.success) {
      results.sent++;
      if (result.messageSid) results.sids.push(result.messageSid);
    } else {
      results.failed++;
    }
  }

  return results;
}
```

4. Add API_URL to env.ts if not already present (optional, can be set in deployment)
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm exec tsc --noEmit`
Test locally: Send a test SMS, verify MessageSid is returned.
  </verify>
  <done>
sendSms returns SendSmsResult with messageSid for tracking.
statusCallback URL included in Twilio API calls.
Twilio will POST status updates to /api/webhooks/sms-status.
  </done>
</task>

<task type="auto">
  <name>Task 3: Store MessageSid in notification service</name>
  <files>apps/api/src/services/notifications.ts</files>
  <action>
Update the sendNotification function to store the Twilio MessageSid in NotificationLog for webhook matching.

1. Import the updated SendSmsResult type if needed

2. In the SMS sending section, after calling sendSms(), update the NotificationLog with the returned messageSid:

```typescript
// When sending SMS
const smsResult = await sendSms({
  to: payload.data.clientPhone!,
  message: smsMessage,
});

if (smsResult.success && smsResult.messageSid) {
  // Store MessageSid for webhook matching
  await prisma.notificationLog.update({
    where: { id: notification.id },
    data: {
      smsStatus: 'sent',
      smsSentAt: new Date(),
      twilioMessageSid: smsResult.messageSid,
    },
  });
} else {
  // SMS failed at API level
  await prisma.notificationLog.update({
    where: { id: notification.id },
    data: {
      smsStatus: 'failed',
      smsError: smsResult.error || 'Unknown error',
    },
  });

  // Trigger fallback to email if available
  // ... existing fallback logic
}
```

3. Ensure the notification service properly updates status based on SMS send result.
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm exec tsc --noEmit`
Test: Make a booking, verify NotificationLog has twilioMessageSid populated.
  </verify>
  <done>
NotificationLog.twilioMessageSid is populated after SMS send.
SMS delivery status can be updated by webhook using this SID.
  </done>
</task>

</tasks>

<verification>
1. API type-checks: `cd apps/api && pnpm exec tsc --noEmit`
2. API builds: `cd apps/api && pnpm run build`
3. SMS webhook endpoint responds to POST /api/webhooks/sms-status
4. sendSms returns messageSid for tracking
5. NotificationLog entries have twilioMessageSid after SMS send
</verification>

<success_criteria>
- Twilio status callbacks received at /api/webhooks/sms-status
- NotificationLog.smsStatus updated from Twilio callbacks (sent/delivered/failed)
- MessageSid stored in NotificationLog for webhook matching
- Webhook responds immediately (200 OK) to avoid Twilio retries
- No breaking changes to existing SMS sending
</success_criteria>

<output>
After completion, create `.planning/phases/05-notification-system/05-02-SUMMARY.md`
</output>
