---
phase: 05-notification-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - apps/api/src/services/notifications.ts
autonomous: true

must_haves:
  truths:
    - "Every notification attempt is logged with unique ID and status"
    - "Notifications can be sent via email, SMS, or both channels"
    - "SMS fallback to email happens when SMS fails and email is available"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "NotificationLog model with delivery tracking fields"
      contains: "model NotificationLog"
    - path: "apps/api/src/services/notifications.ts"
      provides: "Unified notification service facade"
      exports: ["sendNotification", "NotificationPayload"]
  key_links:
    - from: "apps/api/src/services/notifications.ts"
      to: "apps/api/src/services/email.ts"
      via: "sendEmail import"
      pattern: "import.*sendEmail.*from.*email"
    - from: "apps/api/src/services/notifications.ts"
      to: "apps/api/src/services/sms.ts"
      via: "sendSms import"
      pattern: "import.*sendSms.*from.*sms"
    - from: "apps/api/src/services/notifications.ts"
      to: "prisma.notificationLog"
      via: "database logging"
      pattern: "prisma\\.notificationLog\\.(create|update)"
---

<objective>
Create NotificationLog schema and unified notification service that logs all notification attempts and handles SMS-to-email fallback.

Purpose: Establish foundation for delivery tracking and centralized notification management
Output: NotificationLog model in Prisma + notifications.ts service with sendNotification()
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-notification-system/05-CONTEXT.md
@.planning/phases/05-notification-system/05-RESEARCH.md
@packages/database/prisma/schema.prisma
@apps/api/src/services/email.ts
@apps/api/src/services/sms.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NotificationLog model to Prisma schema</name>
  <files>packages/database/prisma/schema.prisma</files>
  <action>
Add NotificationLog model after the existing ReminderLog model. This model tracks the complete lifecycle of each notification attempt.

Fields needed:
- id: String @id @default(uuid())
- salonId: String @map("salon_id") - tenant isolation
- appointmentId: String? @map("appointment_id") - optional, for appointment-related notifications
- clientId: String @map("client_id") - who receives the notification
- type: String - notification type (booking_confirmation, reminder_24h, reminder_2h, cancellation)
- channels: String @default("[]") - JSON array of attempted channels ["email", "sms"]
- status: String @default("pending") - overall status (pending, sent, delivered, failed)
- emailStatus: String? @map("email_status") - email channel status (pending, sent, delivered, bounced, failed)
- emailSentAt: DateTime? @map("email_sent_at")
- emailDeliveredAt: DateTime? @map("email_delivered_at")
- emailError: String? @map("email_error")
- sendgridMessageId: String? @unique @map("sendgrid_message_id") - for webhook matching
- smsStatus: String? @map("sms_status") - SMS channel status (pending, sent, delivered, failed)
- smsSentAt: DateTime? @map("sms_sent_at")
- smsDeliveredAt: DateTime? @map("sms_delivered_at")
- smsError: String? @map("sms_error")
- smsErrorCode: String? @map("sms_error_code") - Twilio error code
- twilioMessageSid: String? @unique @map("twilio_message_sid") - for webhook matching
- retryCount: Int @default(0) @map("retry_count")
- retryAt: DateTime? @map("retry_at") - for retry queue
- createdAt: DateTime @default(now()) @map("created_at")
- updatedAt: DateTime @updatedAt @map("updated_at")

Relations:
- salon: Salon @relation(fields: [salonId], references: [id], onDelete: Cascade)
- appointment: Appointment? @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
- client: Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

Add relation arrays to Salon, Appointment, and Client models.

Indexes:
- @@index([salonId])
- @@index([clientId])
- @@index([appointmentId])
- @@index([status])
- @@index([retryAt])
- @@index([createdAt])
- @@map("notification_logs")

After adding the model, run:
```bash
cd packages/database && pnpm exec prisma generate
```
  </action>
  <verify>
Run `pnpm exec prisma validate` in packages/database - should pass with no errors.
Run `pnpm exec prisma generate` - should generate client successfully.
  </verify>
  <done>
NotificationLog model exists in schema.prisma with all delivery tracking fields.
Prisma client generates successfully.
Relations added to Salon, Appointment, and Client models.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unified notification service</name>
  <files>apps/api/src/services/notifications.ts</files>
  <action>
Create a new notification service that acts as a facade for SMS and email sending with consistent logging.

Implement:

1. NotificationPayload interface:
```typescript
export interface NotificationPayload {
  salonId: string;
  clientId: string;
  appointmentId?: string;
  type: 'booking_confirmation' | 'reminder_24h' | 'reminder_2h' | 'cancellation';
  channels: ('email' | 'sms')[];
  data: {
    clientName: string;
    clientEmail?: string;
    clientPhone?: string;
    serviceName: string;
    staffName: string;
    dateTime: string;
    salonName: string;
    salonAddress: string;
    // For calendar integration (added in Plan 03)
    startTime?: Date;
    endTime?: Date;
    salonTimezone?: string;
  };
}
```

2. sendNotification function:
- Create NotificationLog entry with status 'pending'
- For each channel (email first, then SMS):
  - Attempt to send using existing email.ts/sms.ts services
  - Update NotificationLog with channel-specific status
  - If SMS fails AND email is in channels AND client has email, try email as fallback
- Update overall status based on channel results
- Return notification ID for tracking

3. Status determination logic:
- 'sent' if at least one channel succeeded at the API level
- 'failed' if all channels failed
- 'pending' should never be the final status (transient only)

4. Error handling:
- Wrap all send calls in try/catch
- Log errors to NotificationLog.emailError or smsError fields
- Never throw - always return result object

5. Export types and function.
  </action>
  <verify>
File exists at apps/api/src/services/notifications.ts.
TypeScript compiles without errors: `cd apps/api && pnpm exec tsc --noEmit`
  </verify>
  <done>
notifications.ts exports sendNotification function and NotificationPayload type.
Service creates NotificationLog entries for every send attempt.
SMS failure triggers email fallback when email channel is available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire notification service to booking confirmation</name>
  <files>apps/api/src/routes/public.ts</files>
  <action>
Update the public booking endpoint to use the new unified notification service for booking confirmations.

1. Import the new service at the top of the file:
```typescript
import { sendNotification } from '../services/notifications.js';
```

2. Find the booking confirmation section (around line 839-874) where sendEmail and sendSms are called directly.

3. Replace the direct sendEmail/sendSms calls with a single sendNotification call:
```typescript
// Determine channels based on client preferences
const channels: ('email' | 'sms')[] = [];
if (client.email) channels.push('email');
if (client.phone && optInReminders) channels.push('sms');

if (channels.length > 0) {
  try {
    await sendNotification({
      salonId: salon.id,
      clientId: client.id,
      appointmentId: appointment.id,
      type: 'booking_confirmation',
      channels,
      data: {
        clientName: client.firstName,
        clientEmail: client.email || undefined,
        clientPhone: client.phone || undefined,
        serviceName: service.name,
        staffName: `${appointment.staff.firstName} ${appointment.staff.lastName}`,
        dateTime: formattedDateTime,
        salonName: salon.name,
        salonAddress: appointmentAddress,
        startTime: appointment.startTime,
        endTime: appointment.endTime,
        salonTimezone: salon.timezone,
      },
    });
  } catch (e) {
    console.error('Failed to send booking confirmation:', e);
    // Don't block booking completion on notification failure
  }
}
```

4. Keep the old direct send calls commented out briefly for reference during testing.
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm exec tsc --noEmit`
Test locally: Start API, make a test booking through public endpoint, verify NotificationLog entry created in database.
  </verify>
  <done>
Public booking endpoint uses sendNotification for confirmations.
NotificationLog entries created for each booking confirmation attempt.
Existing booking flow continues to work.
  </done>
</task>

</tasks>

<verification>
1. Prisma schema validates: `cd packages/database && pnpm exec prisma validate`
2. Database package builds: `cd packages/database && pnpm run build`
3. API package type-checks: `cd apps/api && pnpm exec tsc --noEmit`
4. NotificationLog model has all delivery tracking fields
5. notifications.ts exports sendNotification and types
6. Public booking creates NotificationLog entries
</verification>

<success_criteria>
- NotificationLog model exists with email/SMS status tracking fields
- Unified sendNotification() function handles all notification types
- Booking confirmations logged in NotificationLog table
- SMS failure triggers email fallback
- No breaking changes to existing booking flow
</success_criteria>

<output>
After completion, create `.planning/phases/05-notification-system/05-01-SUMMARY.md`
</output>
