---
phase: 05-notification-system
plan: 04
type: execute
wave: 3
depends_on: ["05-01"]
files_modified:
  - packages/database/prisma/schema.prisma
  - apps/api/src/routes/salon.ts
  - apps/api/src/cron/appointmentReminders.ts
autonomous: true

must_haves:
  truths:
    - "Each salon can configure when reminders are sent (e.g., 24h, 2h, both, or custom)"
    - "Reminder timing preferences are persisted in salon settings"
    - "Cron job respects per-salon reminder timing configuration"
  artifacts:
    - path: "apps/api/src/routes/salon.ts"
      provides: "API endpoint to update notification settings"
      contains: "notification-settings"
    - path: "apps/api/src/cron/appointmentReminders.ts"
      provides: "Configurable reminder timing from salon settings"
      contains: "salonTimings"
  key_links:
    - from: "apps/api/src/cron/appointmentReminders.ts"
      to: "Salon.notification_settings"
      via: "JSON parse of settings"
      pattern: "notification_settings"
---

<objective>
Implement configurable reminder timing per salon, replacing the hardcoded 24h/2h reminders.

Purpose: Allow each salon to customize when reminders are sent (e.g., 48h + 2h, or just 24h)
Output: Notification settings API endpoint + cron job respects salon-specific timing
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-notification-system/05-CONTEXT.md
@.planning/phases/05-notification-system/05-RESEARCH.md
@.planning/phases/05-notification-system/05-01-SUMMARY.md
@apps/api/src/routes/salon.ts
@apps/api/src/cron/appointmentReminders.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define notification settings structure and API</name>
  <files>apps/api/src/routes/salon.ts</files>
  <action>
Add an endpoint to get and update notification settings for a salon.

1. First, define the notification settings interface (can be at top of file or in a types file):
```typescript
// Notification settings structure stored in Salon.notification_settings (JSON)
interface NotificationSettings {
  reminders: {
    enabled: boolean;
    timings: { hours: number; label: string }[];  // e.g., [{ hours: 24, label: '24 hours' }]
  };
  channels: {
    email: boolean;
    sms: boolean;
  };
  // Future: custom templates, etc.
}

// Default settings
const DEFAULT_NOTIFICATION_SETTINGS: NotificationSettings = {
  reminders: {
    enabled: true,
    timings: [
      { hours: 24, label: '24 hours before' },
      { hours: 2, label: '2 hours before' },
    ],
  },
  channels: {
    email: true,
    sms: true,
  },
};
```

2. Add GET endpoint for notification settings:
```typescript
// GET /salon/notification-settings
router.get('/notification-settings', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const salon = await prisma.salon.findUnique({
    where: { id: req.user!.salonId },
    select: { notification_settings: true },
  });

  if (!salon) {
    return res.status(404).json({ success: false, error: { code: 'NOT_FOUND', message: 'Salon not found' } });
  }

  let settings: NotificationSettings;
  try {
    settings = salon.notification_settings
      ? JSON.parse(salon.notification_settings)
      : DEFAULT_NOTIFICATION_SETTINGS;
  } catch {
    settings = DEFAULT_NOTIFICATION_SETTINGS;
  }

  res.json({ success: true, data: settings });
}));
```

3. Add PUT endpoint to update notification settings:
```typescript
// PUT /salon/notification-settings
router.put('/notification-settings', authenticate, asyncHandler(async (req: Request, res: Response) => {
  // Only owner/admin can change notification settings
  if (!['owner', 'admin'].includes(req.user!.role)) {
    return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'Only owners and admins can update notification settings' } });
  }

  const { reminders, channels } = req.body;

  // Validate reminder timings
  if (reminders?.timings) {
    if (!Array.isArray(reminders.timings)) {
      return res.status(400).json({ success: false, error: { code: 'INVALID_TIMINGS', message: 'Timings must be an array' } });
    }
    // Validate each timing is a positive number
    for (const timing of reminders.timings) {
      if (typeof timing.hours !== 'number' || timing.hours <= 0 || timing.hours > 168) {  // max 1 week
        return res.status(400).json({ success: false, error: { code: 'INVALID_TIMING', message: 'Each timing must have hours between 1 and 168' } });
      }
    }
  }

  // Get current settings and merge
  const salon = await prisma.salon.findUnique({
    where: { id: req.user!.salonId },
    select: { notification_settings: true },
  });

  let currentSettings: NotificationSettings;
  try {
    currentSettings = salon?.notification_settings
      ? JSON.parse(salon.notification_settings)
      : DEFAULT_NOTIFICATION_SETTINGS;
  } catch {
    currentSettings = DEFAULT_NOTIFICATION_SETTINGS;
  }

  // Merge new settings
  const newSettings: NotificationSettings = {
    reminders: {
      enabled: reminders?.enabled ?? currentSettings.reminders.enabled,
      timings: reminders?.timings ?? currentSettings.reminders.timings,
    },
    channels: {
      email: channels?.email ?? currentSettings.channels.email,
      sms: channels?.sms ?? currentSettings.channels.sms,
    },
  };

  // Save to database
  await prisma.salon.update({
    where: { id: req.user!.salonId },
    data: { notification_settings: JSON.stringify(newSettings) },
  });

  res.json({ success: true, data: newSettings });
}));
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm exec tsc --noEmit`
Test endpoints: GET and PUT /salon/notification-settings
  </verify>
  <done>
GET /salon/notification-settings returns current settings (or defaults).
PUT /salon/notification-settings updates settings with validation.
Settings validated for reasonable timing values (1-168 hours).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update cron job for configurable reminder timing</name>
  <files>apps/api/src/cron/appointmentReminders.ts</files>
  <action>
Modify the reminder cron job to respect per-salon timing configuration instead of hardcoded 24h/2h.

1. Add the NotificationSettings interface and defaults at the top (same as salon.ts):
```typescript
interface NotificationSettings {
  reminders: {
    enabled: boolean;
    timings: { hours: number; label: string }[];
  };
  channels: {
    email: boolean;
    sms: boolean;
  };
}

const DEFAULT_NOTIFICATION_SETTINGS: NotificationSettings = {
  reminders: {
    enabled: true,
    timings: [
      { hours: 24, label: '24 hours before' },
      { hours: 2, label: '2 hours before' },
    ],
  },
  channels: {
    email: true,
    sms: true,
  },
};

function parseNotificationSettings(json: string | null): NotificationSettings {
  if (!json) return DEFAULT_NOTIFICATION_SETTINGS;
  try {
    return JSON.parse(json) as NotificationSettings;
  } catch {
    return DEFAULT_NOTIFICATION_SETTINGS;
  }
}
```

2. Replace the current runAppointmentReminders with a new approach that:
   - Gets all active salons with their notification_settings
   - For each salon, determines which reminder timings are configured
   - Queries appointments matching those timings
   - Sends reminders using the unified notification service

```typescript
export async function runAppointmentReminders(): Promise<void> {
  const startTime = new Date();
  console.log(`\n[AppointmentReminders] Starting at ${startTime.toISOString()}`);

  try {
    // Get all active salons with their notification settings
    const salons = await prisma.salon.findMany({
      where: { isActive: true },
      select: {
        id: true,
        notification_settings: true,
        timezone: true,
        name: true,
      },
    });

    let totalProcessed = 0;
    let totalEmailsSent = 0;
    let totalSmsSent = 0;

    for (const salon of salons) {
      const settings = parseNotificationSettings(salon.notification_settings);

      if (!settings.reminders.enabled) {
        continue;  // Skip salons with reminders disabled
      }

      // Process each configured timing
      for (const timing of settings.reminders.timings) {
        const reminderType = `REMINDER_${timing.hours}H` as ReminderType;
        const results = await processRemindersForSalon(
          salon.id,
          timing.hours,
          reminderType,
          settings.channels
        );

        totalProcessed += results.processed;
        totalEmailsSent += results.emailsSent;
        totalSmsSent += results.smsSent;
      }
    }

    const endTime = new Date();
    const duration = endTime.getTime() - startTime.getTime();

    console.log(`[AppointmentReminders] Completed in ${duration}ms`);
    console.log(`[AppointmentReminders] Summary:`);
    console.log(`  - Salons checked: ${salons.length}`);
    console.log(`  - Total appointments processed: ${totalProcessed}`);
    console.log(`  - Emails sent: ${totalEmailsSent}`);
    console.log(`  - SMS sent: ${totalSmsSent}`);
  } catch (error) {
    console.error('[AppointmentReminders] Fatal error:', error);
  }
}

async function processRemindersForSalon(
  salonId: string,
  hoursAhead: number,
  reminderType: ReminderType,
  channels: { email: boolean; sms: boolean }
): Promise<{ processed: number; emailsSent: number; smsSent: number }> {
  const now = new Date();
  const targetTime = new Date(now.getTime() + hoursAhead * 60 * 60 * 1000);
  const windowStart = new Date(targetTime.getTime() - 30 * 60 * 1000);  // 30 min window
  const windowEnd = new Date(targetTime.getTime() + 30 * 60 * 1000);

  const appointments = await prisma.appointment.findMany({
    where: {
      salonId,
      startTime: {
        gte: windowStart,
        lte: windowEnd,
      },
      status: {
        in: ['confirmed', 'pending'],
      },
      client: {
        optedInReminders: true,
        isActive: true,
      },
    },
    include: {
      client: true,
      staff: true,
      service: true,
      salon: true,
    },
  });

  const results = { processed: 0, emailsSent: 0, smsSent: 0 };

  for (const appointment of appointments) {
    // Check if this specific reminder was already sent
    const alreadySent = await hasReminderBeenSent(appointment.id, reminderType);
    if (alreadySent) continue;

    const result = await sendAppointmentReminder(
      appointment as any,  // Type assertion for existing interface
      reminderType,
      channels
    );

    results.processed++;
    if (result.emailSent) results.emailsSent++;
    if (result.smsSent) results.smsSent++;
  }

  return results;
}
```

3. Update sendAppointmentReminder to respect channel settings:
```typescript
async function sendAppointmentReminder(
  appointment: AppointmentWithDetails,
  reminderType: ReminderType,
  channelConfig: { email: boolean; sms: boolean }
): Promise<ReminderResult> {
  // ... existing setup code ...

  // Only send via channels that are enabled AND that client prefers
  if (client.email && channelConfig.email && (preference === 'email' || preference === 'both')) {
    // Send email
  }

  if (client.phone && channelConfig.sms && (preference === 'sms' || preference === 'both')) {
    // Send SMS
  }

  // ... rest of function
}
```

4. Update ReminderType enum to be dynamic (string-based):
```typescript
// Change from enum to string type to support custom timings
export type ReminderType = string;  // e.g., 'REMINDER_24H', 'REMINDER_2H', 'REMINDER_48H'
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm exec tsc --noEmit`
Test: Manually trigger reminders with different salon settings.
  </verify>
  <done>
Cron job reads each salon's notification_settings.
Reminders sent according to salon-specific timing configuration.
Salons can configure any hour value (1-168) for reminders.
Channels (email/sms) can be enabled/disabled per salon.
  </done>
</task>

</tasks>

<verification>
1. API type-checks: `cd apps/api && pnpm exec tsc --noEmit`
2. API builds: `cd apps/api && pnpm run build`
3. GET /salon/notification-settings returns defaults for new salons
4. PUT /salon/notification-settings saves and returns updated settings
5. Cron job logs show it respects per-salon timing
6. Setting reminders.enabled=false disables reminders for that salon
</verification>

<success_criteria>
- API endpoints for getting and updating notification settings work
- Reminder timing is configurable per salon (e.g., 48h, 24h, 2h, custom)
- Cron job respects salon-specific timing instead of hardcoded values
- Email and SMS channels can be independently enabled/disabled
- Backward compatible - salons without settings use defaults (24h, 2h)
</success_criteria>

<output>
After completion, create `.planning/phases/05-notification-system/05-04-SUMMARY.md`
</output>
