---
phase: 05-notification-system
plan: 05
type: execute
wave: 4
depends_on: ["05-01", "05-02", "05-04"]
files_modified:
  - apps/api/src/routes/notifications.ts
  - apps/api/src/app.ts
  - apps/web/src/hooks/useNotifications.ts
  - apps/web/src/app/notifications/page.tsx
autonomous: false

user_setup: []

must_haves:
  truths:
    - "Owner can view notification history for their salon"
    - "Notification history shows status (sent/delivered/failed) for each attempt"
    - "Owner can filter notifications by type, status, and date range"
    - "Owner can resend failed notifications with one click"
  artifacts:
    - path: "apps/api/src/routes/notifications.ts"
      provides: "Notification history API endpoints"
      exports: ["notificationsRouter"]
    - path: "apps/web/src/app/notifications/page.tsx"
      provides: "Notification history page in owner dashboard"
      contains: "NotificationLog"
  key_links:
    - from: "apps/web/src/app/notifications/page.tsx"
      to: "/api/notifications"
      via: "useNotifications hook fetch"
      pattern: "fetch.*notifications"
    - from: "apps/api/src/routes/notifications.ts"
      to: "prisma.notificationLog"
      via: "database query"
      pattern: "prisma\\.notificationLog\\.findMany"
---

<objective>
Create notification history API and frontend page so salon owners can view sent notifications and resend failed ones.

Purpose: Owner visibility into notification delivery status and ability to retry failed sends
Output: Backend API + Frontend notifications page with history list and resend button
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-notification-system/05-CONTEXT.md
@.planning/phases/05-notification-system/05-RESEARCH.md
@.planning/phases/05-notification-system/05-01-SUMMARY.md
@.planning/phases/05-notification-system/05-02-SUMMARY.md
@.planning/phases/05-notification-system/05-04-SUMMARY.md
@apps/api/src/app.ts
@apps/web/src/hooks/useClients.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notifications API routes</name>
  <files>apps/api/src/routes/notifications.ts, apps/api/src/app.ts</files>
  <action>
Create a new notifications router with endpoints for listing and resending notifications.

1. Create apps/api/src/routes/notifications.ts:
```typescript
import { Router, Request, Response } from 'express';
import { prisma } from '@peacase/database';
import { authenticate } from '../middleware/auth.js';
import { asyncHandler } from '../lib/errorUtils.js';
import { sendNotification, NotificationPayload } from '../services/notifications.js';

const router = Router();

// GET /notifications - List notification history
router.get('/', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const salonId = req.user!.salonId;
  const {
    type,
    status,
    clientId,
    startDate,
    endDate,
    page = '1',
    limit = '50',
  } = req.query;

  const pageNum = parseInt(page as string, 10);
  const limitNum = Math.min(parseInt(limit as string, 10), 100);  // Max 100 per page
  const skip = (pageNum - 1) * limitNum;

  // Build where clause
  const where: any = { salonId };

  if (type) where.type = type;
  if (status) where.status = status;
  if (clientId) where.clientId = clientId;

  if (startDate || endDate) {
    where.createdAt = {};
    if (startDate) where.createdAt.gte = new Date(startDate as string);
    if (endDate) where.createdAt.lte = new Date(endDate as string);
  }

  const [notifications, total] = await Promise.all([
    prisma.notificationLog.findMany({
      where,
      include: {
        client: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            phone: true,
          },
        },
        appointment: {
          select: {
            id: true,
            startTime: true,
            service: {
              select: { name: true },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
      skip,
      take: limitNum,
    }),
    prisma.notificationLog.count({ where }),
  ]);

  res.json({
    success: true,
    data: notifications,
    pagination: {
      page: pageNum,
      limit: limitNum,
      total,
      totalPages: Math.ceil(total / limitNum),
    },
  });
}));

// GET /notifications/stats - Get notification statistics
router.get('/stats', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const salonId = req.user!.salonId;
  const { startDate, endDate } = req.query;

  const where: any = { salonId };
  if (startDate || endDate) {
    where.createdAt = {};
    if (startDate) where.createdAt.gte = new Date(startDate as string);
    if (endDate) where.createdAt.lte = new Date(endDate as string);
  }

  // Get counts by status
  const [total, sent, delivered, failed] = await Promise.all([
    prisma.notificationLog.count({ where }),
    prisma.notificationLog.count({ where: { ...where, status: 'sent' } }),
    prisma.notificationLog.count({ where: { ...where, status: 'delivered' } }),
    prisma.notificationLog.count({ where: { ...where, status: 'failed' } }),
  ]);

  res.json({
    success: true,
    data: {
      total,
      sent,
      delivered,
      failed,
      successRate: total > 0 ? ((sent + delivered) / total * 100).toFixed(1) : '100',
    },
  });
}));

// GET /notifications/:id - Get single notification
router.get('/:id', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const notification = await prisma.notificationLog.findFirst({
    where: {
      id: req.params.id,
      salonId: req.user!.salonId,
    },
    include: {
      client: true,
      appointment: {
        include: {
          service: true,
          staff: true,
        },
      },
    },
  });

  if (!notification) {
    return res.status(404).json({
      success: false,
      error: { code: 'NOT_FOUND', message: 'Notification not found' },
    });
  }

  res.json({ success: true, data: notification });
}));

// POST /notifications/:id/resend - Resend a failed notification
router.post('/:id/resend', authenticate, asyncHandler(async (req: Request, res: Response) => {
  // Only owner/admin can resend
  if (!['owner', 'admin'].includes(req.user!.role)) {
    return res.status(403).json({
      success: false,
      error: { code: 'FORBIDDEN', message: 'Only owners and admins can resend notifications' },
    });
  }

  const notification = await prisma.notificationLog.findFirst({
    where: {
      id: req.params.id,
      salonId: req.user!.salonId,
    },
    include: {
      client: true,
      appointment: {
        include: {
          service: true,
          staff: true,
          salon: true,
          location: true,
        },
      },
    },
  });

  if (!notification) {
    return res.status(404).json({
      success: false,
      error: { code: 'NOT_FOUND', message: 'Notification not found' },
    });
  }

  // Build address
  const loc = notification.appointment?.location;
  const salon = notification.appointment?.salon;
  const address = loc
    ? `${loc.address || ''}, ${loc.city || ''}, ${loc.state || ''} ${loc.zip || ''}`.trim()
    : salon
    ? `${salon.address || ''}, ${salon.city || ''}, ${salon.state || ''} ${salon.zip || ''}`.trim()
    : '';

  // Determine channels to use
  const channels: ('email' | 'sms')[] = [];
  if (notification.client.email) channels.push('email');
  if (notification.client.phone) channels.push('sms');

  if (channels.length === 0) {
    return res.status(400).json({
      success: false,
      error: { code: 'NO_CONTACT', message: 'Client has no email or phone' },
    });
  }

  // Format datetime
  const dateTime = notification.appointment?.startTime
    ? new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: salon?.timezone || 'UTC',
      }).format(notification.appointment.startTime)
    : '';

  // Send new notification
  const newNotificationId = await sendNotification({
    salonId: notification.salonId,
    clientId: notification.clientId,
    appointmentId: notification.appointmentId || undefined,
    type: notification.type as any,
    channels,
    data: {
      clientName: notification.client.firstName,
      clientEmail: notification.client.email || undefined,
      clientPhone: notification.client.phone || undefined,
      serviceName: notification.appointment?.service?.name || 'Service',
      staffName: notification.appointment?.staff
        ? `${notification.appointment.staff.firstName} ${notification.appointment.staff.lastName}`
        : 'Staff',
      dateTime,
      salonName: salon?.name || '',
      salonAddress: address,
      startTime: notification.appointment?.startTime,
      endTime: notification.appointment?.endTime,
      salonTimezone: salon?.timezone,
    },
  });

  res.json({
    success: true,
    data: { notificationId: newNotificationId },
    message: 'Notification resent successfully',
  });
}));

export { router as notificationsRouter };
```

2. Add the router to app.ts:
```typescript
import { notificationsRouter } from './routes/notifications.js';

// Add with other routes
app.use('/api/notifications', notificationsRouter);
```
  </action>
  <verify>
TypeScript compiles: `cd apps/api && pnpm exec tsc --noEmit`
Test endpoints: GET /notifications, GET /notifications/stats, POST /notifications/:id/resend
  </verify>
  <done>
Notification history API endpoints working.
Supports filtering by type, status, date range, client.
Resend endpoint sends new notification for failed ones.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notifications hook</name>
  <files>apps/web/src/hooks/useNotifications.ts</files>
  <action>
Create a React hook for fetching and managing notification history.

```typescript
import { useState, useEffect, useCallback } from 'react';
import { api } from '@/lib/api';

export interface NotificationLog {
  id: string;
  salonId: string;
  clientId: string;
  appointmentId: string | null;
  type: string;
  channels: string;
  status: string;
  emailStatus: string | null;
  emailSentAt: string | null;
  emailDeliveredAt: string | null;
  emailError: string | null;
  smsStatus: string | null;
  smsSentAt: string | null;
  smsDeliveredAt: string | null;
  smsError: string | null;
  smsErrorCode: string | null;
  retryCount: number;
  createdAt: string;
  updatedAt: string;
  client: {
    id: string;
    firstName: string;
    lastName: string;
    email: string | null;
    phone: string | null;
  };
  appointment: {
    id: string;
    startTime: string;
    service: { name: string };
  } | null;
}

export interface NotificationStats {
  total: number;
  sent: number;
  delivered: number;
  failed: number;
  successRate: string;
}

export interface NotificationFilters {
  type?: string;
  status?: string;
  clientId?: string;
  startDate?: string;
  endDate?: string;
  page?: number;
  limit?: number;
}

export function useNotifications(filters: NotificationFilters = {}) {
  const [notifications, setNotifications] = useState<NotificationLog[]>([]);
  const [stats, setStats] = useState<NotificationStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 50,
    total: 0,
    totalPages: 0,
  });

  const fetchNotifications = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const params = new URLSearchParams();
      if (filters.type) params.set('type', filters.type);
      if (filters.status) params.set('status', filters.status);
      if (filters.clientId) params.set('clientId', filters.clientId);
      if (filters.startDate) params.set('startDate', filters.startDate);
      if (filters.endDate) params.set('endDate', filters.endDate);
      if (filters.page) params.set('page', filters.page.toString());
      if (filters.limit) params.set('limit', filters.limit.toString());

      const res = await api.get(`/notifications?${params.toString()}`);

      if (res.success) {
        setNotifications(res.data);
        setPagination(res.pagination);
      } else {
        setError(res.error?.message || 'Failed to load notifications');
      }
    } catch (err) {
      setError('Failed to load notifications');
    } finally {
      setLoading(false);
    }
  }, [filters]);

  const fetchStats = useCallback(async () => {
    try {
      const params = new URLSearchParams();
      if (filters.startDate) params.set('startDate', filters.startDate);
      if (filters.endDate) params.set('endDate', filters.endDate);

      const res = await api.get(`/notifications/stats?${params.toString()}`);
      if (res.success) {
        setStats(res.data);
      }
    } catch (err) {
      console.error('Failed to load stats:', err);
    }
  }, [filters.startDate, filters.endDate]);

  const resendNotification = async (notificationId: string): Promise<boolean> => {
    try {
      const res = await api.post(`/notifications/${notificationId}/resend`, {});
      if (res.success) {
        // Refresh the list
        await fetchNotifications();
        return true;
      }
      return false;
    } catch (err) {
      return false;
    }
  };

  useEffect(() => {
    fetchNotifications();
    fetchStats();
  }, [fetchNotifications, fetchStats]);

  return {
    notifications,
    stats,
    loading,
    error,
    pagination,
    refresh: fetchNotifications,
    resendNotification,
  };
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/web && pnpm exec tsc --noEmit`
  </verify>
  <done>
useNotifications hook exports notification list, stats, and resend function.
Supports filtering, pagination, and refresh.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create notifications page</name>
  <files>apps/web/src/app/notifications/page.tsx</files>
  <action>
Create the notifications history page in the owner dashboard.

```typescript
'use client';

import { useState } from 'react';
import { useNotifications, NotificationLog, NotificationFilters } from '@/hooks/useNotifications';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { RefreshCw, Send, Mail, MessageSquare, CheckCircle, XCircle, Clock, AlertCircle } from 'lucide-react';
import { toast } from 'sonner';
import { formatDistanceToNow } from 'date-fns';

export default function NotificationsPage() {
  const [filters, setFilters] = useState<NotificationFilters>({
    page: 1,
    limit: 50,
  });

  const { notifications, stats, loading, error, pagination, refresh, resendNotification } = useNotifications(filters);
  const [resending, setResending] = useState<string | null>(null);

  const handleResend = async (notificationId: string) => {
    setResending(notificationId);
    const success = await resendNotification(notificationId);
    setResending(null);

    if (success) {
      toast.success('Notification resent successfully');
    } else {
      toast.error('Failed to resend notification');
    }
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'delivered':
        return <Badge className="bg-green-100 text-green-800"><CheckCircle className="w-3 h-3 mr-1" /> Delivered</Badge>;
      case 'sent':
        return <Badge className="bg-blue-100 text-blue-800"><Clock className="w-3 h-3 mr-1" /> Sent</Badge>;
      case 'failed':
        return <Badge className="bg-red-100 text-red-800"><XCircle className="w-3 h-3 mr-1" /> Failed</Badge>;
      case 'pending':
        return <Badge className="bg-yellow-100 text-yellow-800"><Clock className="w-3 h-3 mr-1" /> Pending</Badge>;
      default:
        return <Badge variant="secondary">{status}</Badge>;
    }
  };

  const getTypeLabel = (type: string) => {
    const labels: Record<string, string> = {
      'booking_confirmation': 'Booking Confirmation',
      'reminder_24h': '24h Reminder',
      'reminder_2h': '2h Reminder',
      'cancellation': 'Cancellation',
    };
    return labels[type] || type;
  };

  if (error) {
    return (
      <div className="p-6">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-center text-red-500">
              <AlertCircle className="w-5 h-5 mr-2" />
              {error}
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold">Notification History</h1>
          <p className="text-muted-foreground">Track SMS and email notifications sent to clients</p>
        </div>
        <Button onClick={refresh} variant="outline" disabled={loading}>
          <RefreshCw className={`w-4 h-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
          Refresh
        </Button>
      </div>

      {/* Stats Cards */}
      {stats && (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Card>
            <CardHeader className="pb-2">
              <CardDescription>Total Sent</CardDescription>
              <CardTitle className="text-2xl">{stats.total}</CardTitle>
            </CardHeader>
          </Card>
          <Card>
            <CardHeader className="pb-2">
              <CardDescription>Delivered</CardDescription>
              <CardTitle className="text-2xl text-green-600">{stats.delivered}</CardTitle>
            </CardHeader>
          </Card>
          <Card>
            <CardHeader className="pb-2">
              <CardDescription>Failed</CardDescription>
              <CardTitle className="text-2xl text-red-600">{stats.failed}</CardTitle>
            </CardHeader>
          </Card>
          <Card>
            <CardHeader className="pb-2">
              <CardDescription>Success Rate</CardDescription>
              <CardTitle className="text-2xl">{stats.successRate}%</CardTitle>
            </CardHeader>
          </Card>
        </div>
      )}

      {/* Filters */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex gap-4 flex-wrap">
            <Select
              value={filters.type || 'all'}
              onValueChange={(value) => setFilters({ ...filters, type: value === 'all' ? undefined : value, page: 1 })}
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Filter by type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Types</SelectItem>
                <SelectItem value="booking_confirmation">Booking Confirmation</SelectItem>
                <SelectItem value="reminder_24h">24h Reminder</SelectItem>
                <SelectItem value="reminder_2h">2h Reminder</SelectItem>
                <SelectItem value="cancellation">Cancellation</SelectItem>
              </SelectContent>
            </Select>

            <Select
              value={filters.status || 'all'}
              onValueChange={(value) => setFilters({ ...filters, status: value === 'all' ? undefined : value, page: 1 })}
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Filter by status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Statuses</SelectItem>
                <SelectItem value="delivered">Delivered</SelectItem>
                <SelectItem value="sent">Sent</SelectItem>
                <SelectItem value="failed">Failed</SelectItem>
                <SelectItem value="pending">Pending</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {/* Notifications List */}
      <Card>
        <CardHeader>
          <CardTitle>Recent Notifications</CardTitle>
          <CardDescription>
            Showing {notifications.length} of {pagination.total} notifications
          </CardDescription>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="space-y-4">
              {[1, 2, 3].map((i) => (
                <Skeleton key={i} className="h-20 w-full" />
              ))}
            </div>
          ) : notifications.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              No notifications found
            </div>
          ) : (
            <div className="space-y-4">
              {notifications.map((notification) => (
                <div
                  key={notification.id}
                  className="flex items-start justify-between p-4 border rounded-lg"
                >
                  <div className="space-y-1">
                    <div className="flex items-center gap-2">
                      {getStatusBadge(notification.status)}
                      <Badge variant="outline">{getTypeLabel(notification.type)}</Badge>
                    </div>
                    <p className="font-medium">
                      {notification.client.firstName} {notification.client.lastName}
                    </p>
                    <div className="flex items-center gap-4 text-sm text-muted-foreground">
                      {notification.emailStatus && (
                        <span className="flex items-center gap-1">
                          <Mail className="w-3 h-3" />
                          {notification.emailStatus}
                        </span>
                      )}
                      {notification.smsStatus && (
                        <span className="flex items-center gap-1">
                          <MessageSquare className="w-3 h-3" />
                          {notification.smsStatus}
                        </span>
                      )}
                      <span>
                        {formatDistanceToNow(new Date(notification.createdAt), { addSuffix: true })}
                      </span>
                    </div>
                    {(notification.emailError || notification.smsError) && (
                      <p className="text-sm text-red-500">
                        {notification.emailError || notification.smsError}
                      </p>
                    )}
                  </div>
                  {notification.status === 'failed' && (
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => handleResend(notification.id)}
                      disabled={resending === notification.id}
                    >
                      {resending === notification.id ? (
                        <RefreshCw className="w-4 h-4 animate-spin" />
                      ) : (
                        <>
                          <Send className="w-4 h-4 mr-1" />
                          Resend
                        </>
                      )}
                    </Button>
                  )}
                </div>
              ))}
            </div>
          )}

          {/* Pagination */}
          {pagination.totalPages > 1 && (
            <div className="flex justify-center gap-2 mt-4">
              <Button
                variant="outline"
                size="sm"
                disabled={pagination.page === 1}
                onClick={() => setFilters({ ...filters, page: pagination.page - 1 })}
              >
                Previous
              </Button>
              <span className="flex items-center px-4">
                Page {pagination.page} of {pagination.totalPages}
              </span>
              <Button
                variant="outline"
                size="sm"
                disabled={pagination.page === pagination.totalPages}
                onClick={() => setFilters({ ...filters, page: pagination.page + 1 })}
              >
                Next
              </Button>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/web && pnpm exec tsc --noEmit`
Web app builds: `cd apps/web && pnpm run build`
Page accessible at /notifications
  </verify>
  <done>
Notifications page displays history with filtering.
Stats cards show total, delivered, failed, success rate.
Resend button works for failed notifications.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Notification history API and frontend page with:
- List of all notifications with status (sent/delivered/failed)
- Statistics cards showing success rate
- Filters for type and status
- One-click resend for failed notifications
  </what-built>
  <how-to-verify>
1. Start both API and web app locally
2. Navigate to /notifications in the browser
3. Verify the page loads with stats and notification list
4. Test filtering by type and status
5. If any failed notifications exist, test the resend button
6. Verify a new notification is created after resend
  </how-to-verify>
  <resume-signal>Type "approved" if the notifications page works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. API type-checks: `cd apps/api && pnpm exec tsc --noEmit`
2. Web type-checks: `cd apps/web && pnpm exec tsc --noEmit`
3. Both apps build successfully
4. Notifications page displays notification history
5. Filtering works for type and status
6. Resend button sends new notification and refreshes list
</verification>

<success_criteria>
- GET /notifications returns paginated notification history
- GET /notifications/stats returns success/failure counts
- POST /notifications/:id/resend creates new notification attempt
- Frontend page displays notifications with status badges
- Filters work for type and status
- Resend button functional for failed notifications
- Human verification confirms page works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05-notification-system/05-05-SUMMARY.md`
</output>
