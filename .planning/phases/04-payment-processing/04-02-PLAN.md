---
phase: 04-payment-processing
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/src/services/payments.ts
  - apps/api/src/routes/webhooks.ts
  - apps/api/src/lib/stripeHelpers.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/public/:slug/book can create payment intent when deposit required"
    - "Webhook handler checks idempotency before processing payment events"
    - "Payment intent includes salon metadata for tracking"
    - "Decline error codes translate to user-friendly messages"
  artifacts:
    - path: "apps/api/src/lib/stripeHelpers.ts"
      provides: "Deposit calculation, decline message translation"
      exports: ["calculateDeposit", "getDeclineMessage"]
    - path: "apps/api/src/services/payments.ts"
      provides: "Payment intent creation with manual capture for deposits"
      exports: ["createDepositPaymentIntent"]
    - path: "apps/api/src/routes/webhooks.ts"
      provides: "Idempotent webhook handlers for payment events"
      contains: "checkAndMarkEventProcessed"
  key_links:
    - from: "apps/api/src/routes/webhooks.ts"
      to: "apps/api/src/services/webhookEvents.ts"
      via: "import checkAndMarkEventProcessed"
      pattern: "checkAndMarkEventProcessed"
    - from: "apps/api/src/routes/webhooks.ts"
      to: "prisma.appointment"
      via: "update appointment status on payment success"
      pattern: "prisma\\.appointment\\.update"
---

<objective>
Implement backend payment endpoints for deposit collection with idempotent webhook handling.

Purpose: Enable clients to pay deposits at booking time, with reliable webhook processing that handles retries and duplicates safely.
Output: Payment intent creation endpoint, updated webhook handlers with idempotency, helper functions for deposit calculation.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-processing/04-RESEARCH.md
@.planning/phases/04-payment-processing/04-01-SUMMARY.md
@apps/api/src/services/payments.ts
@apps/api/src/routes/webhooks.ts
@apps/api/src/services/booking.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe helper functions</name>
  <files>apps/api/src/lib/stripeHelpers.ts</files>
  <action>
Create a new helper file with utility functions for payment processing:

```typescript
/**
 * Calculate deposit amount based on service price and salon settings.
 * Always returns integer cents for Stripe API.
 *
 * @param servicePrice - Service price in dollars (e.g., 65.00)
 * @param depositPercentage - Percentage to charge as deposit (default 20)
 * @returns Amount in cents (e.g., 1300 for $13.00)
 */
export function calculateDepositCents(
  servicePrice: number,
  depositPercentage: number = 20
): number {
  // Calculate deposit in dollars, then convert to cents
  const depositDollars = servicePrice * (depositPercentage / 100);
  // Round to avoid floating point issues, ensure minimum of 50 cents (Stripe minimum)
  return Math.max(50, Math.round(depositDollars * 100));
}

/**
 * Convert Stripe decline codes to user-friendly messages.
 * Based on Stripe's decline code documentation.
 */
export function getDeclineMessage(declineCode: string | null | undefined): string {
  const messages: Record<string, string> = {
    card_declined: "Your card was declined. Please try a different payment method.",
    insufficient_funds: "Insufficient funds. Please try a different card.",
    incorrect_cvc: "Your card's security code is incorrect. Please check and try again.",
    expired_card: "Your card has expired. Please use a different card.",
    processing_error: "A temporary error occurred. Please try again in a moment.",
    incorrect_number: "Your card number is incorrect. Please check and try again.",
    incorrect_zip: "Your ZIP/postal code is incorrect. Please check and try again.",
    card_not_supported: "This card type is not supported. Please try a different card.",
    currency_not_supported: "This currency is not supported by your card.",
    duplicate_transaction: "A duplicate transaction was detected. Please wait a moment.",
    fraudulent: "This transaction could not be processed. Please contact your bank.",
    generic_decline: "Your card was declined. Please contact your bank for more information.",
    invalid_account: "Your card account is invalid. Please contact your bank.",
    lost_card: "This card has been reported lost. Please use a different card.",
    stolen_card: "This card has been reported stolen. Please use a different card.",
    new_account_information_available: "Please update your card information and try again.",
    try_again_later: "Please try again in a few minutes.",
  };

  return messages[declineCode || ''] ||
    "Payment could not be processed. Please try again or contact your bank.";
}

/**
 * Format cents to dollars for display.
 */
export function formatCentsToDollars(cents: number): string {
  return `$${(cents / 100).toFixed(2)}`;
}
```
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
Test calculateDepositCents: 100 price, 20% = 2000 cents.
  </verify>
  <done>
stripeHelpers.ts exists with calculateDepositCents, getDeclineMessage, and formatCentsToDollars functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add deposit payment intent creation to payments service</name>
  <files>apps/api/src/services/payments.ts</files>
  <action>
Add a new function to create payment intents specifically for booking deposits:

```typescript
// Add this import at the top
import { calculateDepositCents } from '../lib/stripeHelpers.js';

// Add this interface
interface CreateDepositPaymentIntentOptions {
  salonId: string;
  serviceId: string;
  clientId: string;
  clientEmail: string;
  servicePrice: number;
  depositPercentage: number;
  appointmentDate: string;
  staffId?: string;
  locationId?: string;
}

// Add this function
export async function createDepositPaymentIntent(
  options: CreateDepositPaymentIntentOptions
): Promise<{ clientSecret: string; depositAmountCents: number }> {
  const depositAmountCents = calculateDepositCents(options.servicePrice, options.depositPercentage);

  const paymentIntent = await stripe().paymentIntents.create({
    amount: depositAmountCents,
    currency: 'usd',
    capture_method: 'manual', // Authorization only - capture when service is rendered
    receipt_email: options.clientEmail,
    metadata: {
      type: 'booking_deposit',
      salonId: options.salonId,
      serviceId: options.serviceId,
      clientId: options.clientId,
      appointmentDate: options.appointmentDate,
      staffId: options.staffId || '',
      locationId: options.locationId || '',
      depositPercentage: options.depositPercentage.toString(),
      servicePrice: options.servicePrice.toString(),
    },
    automatic_payment_methods: { enabled: true },
  });

  if (!paymentIntent.client_secret) {
    throw new Error('Failed to create payment intent: no client secret returned');
  }

  return {
    clientSecret: paymentIntent.client_secret,
    depositAmountCents,
  };
}

// Add function to capture a payment intent (for when service is rendered)
export async function capturePaymentIntent(paymentIntentId: string): Promise<Stripe.PaymentIntent> {
  return stripe().paymentIntents.capture(paymentIntentId);
}

// Add function to cancel a payment intent (for when booking is cancelled before capture)
export async function cancelPaymentIntent(paymentIntentId: string): Promise<Stripe.PaymentIntent> {
  return stripe().paymentIntents.cancel(paymentIntentId);
}
```

Export all new functions from the module.
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile without errors.
Verify exports include createDepositPaymentIntent, capturePaymentIntent, cancelPaymentIntent.
  </verify>
  <done>
payments.ts has createDepositPaymentIntent function that creates Payment Intent with manual capture and metadata for tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update webhook handlers with idempotency</name>
  <files>apps/api/src/routes/webhooks.ts</files>
  <action>
Update the webhook handler to use the idempotency service and handle deposit-related events:

1. Add import at top:
```typescript
import { checkAndMarkEventProcessed } from '../services/webhookEvents.js';
```

2. After signature verification succeeds (after constructWebhookEvent), add idempotency check:
```typescript
  // Idempotency check - has this event been processed?
  const { alreadyProcessed } = await checkAndMarkEventProcessed(event.id, event.type);
  if (alreadyProcessed) {
    return res.json({ received: true, alreadyProcessed: true });
  }
```

3. Update the payment_intent.succeeded handler to update appointment if metadata indicates booking_deposit:
```typescript
case 'payment_intent.succeeded': {
  const paymentIntent = event.data.object as any;
  const metadata = paymentIntent.metadata;

  // Handle booking deposit payments
  if (metadata?.type === 'booking_deposit' && metadata?.appointmentId) {
    await prisma.appointment.update({
      where: { id: metadata.appointmentId },
      data: {
        depositStatus: 'authorized',
        depositAmount: paymentIntent.amount / 100,
        stripePaymentIntentId: paymentIntent.id,
      },
    });

    // Create payment record
    await prisma.payment.create({
      data: {
        salonId: metadata.salonId,
        clientId: metadata.clientId,
        appointmentId: metadata.appointmentId,
        amount: paymentIntent.amount / 100,
        totalAmount: paymentIntent.amount / 100,
        status: 'completed',
        stripePaymentId: paymentIntent.id,
        method: 'card',
      },
    });

    console.log(`[Webhook] Deposit authorized for appointment ${metadata.appointmentId}`);
  } else {
    // Existing behavior for other payments
    await prisma.payment.updateMany({
      where: { stripePaymentId: paymentIntent.id },
      data: { status: 'completed' },
    });
  }
  break;
}
```

4. Update payment_intent.payment_failed handler similarly:
```typescript
case 'payment_intent.payment_failed': {
  const paymentIntent = event.data.object as any;
  const metadata = paymentIntent.metadata;

  if (metadata?.type === 'booking_deposit' && metadata?.appointmentId) {
    await prisma.appointment.update({
      where: { id: metadata.appointmentId },
      data: {
        depositStatus: 'failed',
      },
    });
    console.log(`[Webhook] Deposit failed for appointment ${metadata.appointmentId}`);
  } else {
    await prisma.payment.updateMany({
      where: { stripePaymentId: paymentIntent.id },
      data: { status: 'failed' },
    });
  }
  break;
}
```

5. Add handler for charge.refunded event:
```typescript
case 'charge.refunded': {
  const charge = event.data.object as any;
  const paymentIntentId = charge.payment_intent;

  if (paymentIntentId) {
    // Update appointment deposit status
    await prisma.appointment.updateMany({
      where: { stripePaymentIntentId: paymentIntentId },
      data: { depositStatus: 'refunded' },
    });

    // Update payment record
    await prisma.payment.updateMany({
      where: { stripePaymentId: paymentIntentId },
      data: {
        status: 'refunded',
        refundAmount: charge.amount_refunded / 100,
        refundedAt: new Date(),
      },
    });

    console.log(`[Webhook] Refund processed for payment intent ${paymentIntentId}`);
  }
  break;
}
```
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
Verify webhook handler imports checkAndMarkEventProcessed.
Verify idempotency check happens before processing.
  </verify>
  <done>
Webhook handler uses idempotency service to prevent duplicate processing and handles deposit-related payment events.
  </done>
</task>

</tasks>

<verification>
1. stripeHelpers.ts exists with calculateDepositCents, getDeclineMessage functions
2. payments.ts exports createDepositPaymentIntent function
3. webhooks.ts imports and uses checkAndMarkEventProcessed before processing events
4. Webhook handler updates appointment depositStatus on payment success/failure
5. API compiles without type errors: `pnpm --filter @peacase/api exec tsc --noEmit`
</verification>

<success_criteria>
- Payment intent creation uses manual capture method for deposits
- Webhook handler is idempotent (duplicate events are detected and skipped)
- Decline codes translate to user-friendly messages
- All payment events update relevant appointment records
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-processing/04-02-SUMMARY.md`
</output>
