---
phase: 04-payment-processing
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/src/services/payments.ts
  - apps/api/src/routes/webhooks.ts
  - apps/api/src/lib/stripeHelpers.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/public/:slug/book can create payment intent when deposit required"
    - "Webhook handler checks idempotency before processing payment events"
    - "Payment intent includes salon metadata for tracking"
    - "Decline error codes translate to user-friendly messages"
  artifacts:
    - path: "apps/api/src/lib/stripeHelpers.ts"
      provides: "Deposit calculation, decline message translation"
      exports: ["calculateDeposit", "getDeclineMessage"]
    - path: "apps/api/src/services/payments.ts"
      provides: "Payment intent creation with manual capture for deposits, refund processing"
      exports: ["createDepositPaymentIntent", "capturePaymentIntent", "cancelPaymentIntent", "refundPayment"]
    - path: "apps/api/src/routes/webhooks.ts"
      provides: "Idempotent webhook handlers for payment events"
      contains: "checkAndMarkEventProcessed"
  key_links:
    - from: "apps/api/src/routes/webhooks.ts"
      to: "apps/api/src/services/webhookEvents.ts"
      via: "import checkAndMarkEventProcessed"
      pattern: "checkAndMarkEventProcessed"
    - from: "apps/api/src/routes/webhooks.ts"
      to: "prisma.appointment"
      via: "lookup appointment by stripePaymentIntentId (not by metadata.appointmentId since appointment is created AFTER payment)"
      pattern: "prisma\\.appointment\\.findFirst.*stripePaymentIntentId"
    - from: "apps/api/src/routes/webhooks.ts"
      to: "prisma.payment"
      via: "upsert payment record to prevent duplicates on webhook retries"
      pattern: "prisma\\.payment\\.upsert"
---

<objective>
Implement backend payment endpoints for deposit collection with idempotent webhook handling.

Purpose: Enable clients to pay deposits at booking time, with reliable webhook processing that handles retries and duplicates safely.
Output: Payment intent creation endpoint, updated webhook handlers with idempotency, helper functions for deposit calculation.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-processing/04-RESEARCH.md
@.planning/phases/04-payment-processing/04-01-SUMMARY.md
@apps/api/src/services/payments.ts
@apps/api/src/routes/webhooks.ts
@apps/api/src/services/booking.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe helper functions</name>
  <files>apps/api/src/lib/stripeHelpers.ts</files>
  <action>
Create a new helper file with utility functions for payment processing:

```typescript
/**
 * Calculate deposit amount based on service price and salon settings.
 * Always returns integer cents for Stripe API.
 *
 * @param servicePrice - Service price in dollars (e.g., 65.00)
 * @param depositPercentage - Percentage to charge as deposit (default 20)
 * @returns Amount in cents (e.g., 1300 for $13.00)
 */
export function calculateDepositCents(
  servicePrice: number,
  depositPercentage: number = 20
): number {
  // Calculate deposit in dollars, then convert to cents
  const depositDollars = servicePrice * (depositPercentage / 100);
  // Round to avoid floating point issues, ensure minimum of 50 cents (Stripe minimum)
  return Math.max(50, Math.round(depositDollars * 100));
}

/**
 * Convert Stripe decline codes to user-friendly messages.
 * Based on Stripe's decline code documentation.
 */
export function getDeclineMessage(declineCode: string | null | undefined): string {
  const messages: Record<string, string> = {
    card_declined: "Your card was declined. Please try a different payment method.",
    insufficient_funds: "Insufficient funds. Please try a different card.",
    incorrect_cvc: "Your card's security code is incorrect. Please check and try again.",
    expired_card: "Your card has expired. Please use a different card.",
    processing_error: "A temporary error occurred. Please try again in a moment.",
    incorrect_number: "Your card number is incorrect. Please check and try again.",
    incorrect_zip: "Your ZIP/postal code is incorrect. Please check and try again.",
    card_not_supported: "This card type is not supported. Please try a different card.",
    currency_not_supported: "This currency is not supported by your card.",
    duplicate_transaction: "A duplicate transaction was detected. Please wait a moment.",
    fraudulent: "This transaction could not be processed. Please contact your bank.",
    generic_decline: "Your card was declined. Please contact your bank for more information.",
    invalid_account: "Your card account is invalid. Please contact your bank.",
    lost_card: "This card has been reported lost. Please use a different card.",
    stolen_card: "This card has been reported stolen. Please use a different card.",
    new_account_information_available: "Please update your card information and try again.",
    try_again_later: "Please try again in a few minutes.",
  };

  return messages[declineCode || ''] ||
    "Payment could not be processed. Please try again or contact your bank.";
}

/**
 * Format cents to dollars for display.
 */
export function formatCentsToDollars(cents: number): string {
  return `$${(cents / 100).toFixed(2)}`;
}
```
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
Test calculateDepositCents: 100 price, 20% = 2000 cents.
  </verify>
  <done>
stripeHelpers.ts exists with calculateDepositCents, getDeclineMessage, and formatCentsToDollars functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add deposit payment intent creation to payments service</name>
  <files>apps/api/src/services/payments.ts</files>
  <action>
Add a new function to create payment intents specifically for booking deposits:

```typescript
// Add this import at the top
import { calculateDepositCents } from '../lib/stripeHelpers.js';

// Add this interface
interface CreateDepositPaymentIntentOptions {
  salonId: string;
  serviceId: string;
  clientId: string;
  clientEmail: string;
  servicePrice: number;
  depositPercentage: number;
  appointmentDate: string;
  staffId?: string;
  locationId?: string;
}

// Add this function
export async function createDepositPaymentIntent(
  options: CreateDepositPaymentIntentOptions
): Promise<{ clientSecret: string; depositAmountCents: number }> {
  const depositAmountCents = calculateDepositCents(options.servicePrice, options.depositPercentage);

  const paymentIntent = await stripe().paymentIntents.create({
    amount: depositAmountCents,
    currency: 'usd',
    capture_method: 'manual', // Authorization only - capture when service is rendered
    receipt_email: options.clientEmail,
    metadata: {
      type: 'booking_deposit',
      salonId: options.salonId,
      serviceId: options.serviceId,
      clientId: options.clientId,
      appointmentDate: options.appointmentDate,
      staffId: options.staffId || '',
      locationId: options.locationId || '',
      depositPercentage: options.depositPercentage.toString(),
      servicePrice: options.servicePrice.toString(),
    },
    automatic_payment_methods: { enabled: true },
  });

  if (!paymentIntent.client_secret) {
    throw new Error('Failed to create payment intent: no client secret returned');
  }

  return {
    clientSecret: paymentIntent.client_secret,
    depositAmountCents,
  };
}

// Add function to capture a payment intent (for when service is rendered)
export async function capturePaymentIntent(paymentIntentId: string): Promise<Stripe.PaymentIntent> {
  return stripe().paymentIntents.capture(paymentIntentId);
}

// Add function to cancel a payment intent (for when booking is cancelled before capture)
export async function cancelPaymentIntent(paymentIntentId: string): Promise<Stripe.PaymentIntent> {
  return stripe().paymentIntents.cancel(paymentIntentId);
}

// Add function to refund a captured payment intent (for cancellations after capture)
export async function refundPayment(
  paymentIntentId: string,
  amountCents: number,
  reason?: 'duplicate' | 'fraudulent' | 'requested_by_customer'
): Promise<Stripe.Refund> {
  return stripe().refunds.create({
    payment_intent: paymentIntentId,
    amount: amountCents,
    reason,
  });
}
```

Export all new functions from the module (createDepositPaymentIntent, capturePaymentIntent, cancelPaymentIntent, refundPayment).
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile without errors.
Verify exports include createDepositPaymentIntent, capturePaymentIntent, cancelPaymentIntent, refundPayment.
  </verify>
  <done>
payments.ts has createDepositPaymentIntent function that creates Payment Intent with manual capture and metadata for tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update webhook handlers with idempotency</name>
  <files>apps/api/src/routes/webhooks.ts</files>
  <action>
Update the webhook handler to use the idempotency service and handle deposit-related events:

1. Add import at top:
```typescript
import { checkAndMarkEventProcessed } from '../services/webhookEvents.js';
```

2. After signature verification succeeds (after constructWebhookEvent), add idempotency check:
```typescript
  // Idempotency check - has this event been processed?
  const { alreadyProcessed } = await checkAndMarkEventProcessed(event.id, event.type);
  if (alreadyProcessed) {
    return res.json({ received: true, alreadyProcessed: true });
  }
```

3. Update the payment_intent.succeeded handler to update appointment if metadata indicates booking_deposit.

**IMPORTANT ARCHITECTURE NOTE:** Payment intents are created BEFORE appointments exist (authorization happens before booking creation). The appointment is created AFTER payment succeeds, with the stripePaymentIntentId stored on the appointment. Therefore:
- At payment creation time: No appointmentId exists yet (chicken-and-egg problem)
- At webhook time: Look up appointment by stripePaymentIntentId field, NOT by metadata.appointmentId
- The booking flow in 04-05 creates the appointment with stripePaymentIntentId after payment confirmation

```typescript
case 'payment_intent.succeeded': {
  const paymentIntent = event.data.object as any;
  const metadata = paymentIntent.metadata;

  // Handle booking deposit payments
  if (metadata?.type === 'booking_deposit') {
    // Look up appointment by stripePaymentIntentId (appointment created after payment succeeds)
    // The appointment may not exist yet if webhook fires before booking completion
    const appointment = await prisma.appointment.findFirst({
      where: { stripePaymentIntentId: paymentIntent.id },
    });

    if (appointment) {
      // Appointment exists - update deposit status
      await prisma.appointment.update({
        where: { id: appointment.id },
        data: {
          depositStatus: 'authorized',
          depositAmount: paymentIntent.amount / 100,
        },
      });

      // Upsert payment record (prevent duplicates if webhook retries)
      await prisma.payment.upsert({
        where: { stripePaymentId: paymentIntent.id },
        create: {
          salonId: metadata.salonId,
          clientId: metadata.clientId,
          appointmentId: appointment.id,
          amount: paymentIntent.amount / 100,
          totalAmount: paymentIntent.amount / 100,
          status: 'completed',
          stripePaymentId: paymentIntent.id,
          method: 'card',
        },
        update: {
          status: 'completed',
        },
      });

      console.log(`[Webhook] Deposit authorized for appointment ${appointment.id}`);
    } else {
      // Appointment not created yet - this is normal for booking flow
      // The booking endpoint will create the appointment with depositStatus: 'authorized'
      // after confirming the payment. Log for debugging but no action needed.
      console.log(`[Webhook] Payment intent ${paymentIntent.id} succeeded, awaiting appointment creation`);
    }
  } else {
    // Existing behavior for other payments (subscriptions, full payments, etc.)
    await prisma.payment.updateMany({
      where: { stripePaymentId: paymentIntent.id },
      data: { status: 'completed' },
    });
  }
  break;
}
```

4. Update payment_intent.payment_failed handler similarly (look up by stripePaymentIntentId, not metadata.appointmentId):
```typescript
case 'payment_intent.payment_failed': {
  const paymentIntent = event.data.object as any;
  const metadata = paymentIntent.metadata;

  if (metadata?.type === 'booking_deposit') {
    // Look up appointment by stripePaymentIntentId
    const appointment = await prisma.appointment.findFirst({
      where: { stripePaymentIntentId: paymentIntent.id },
    });

    if (appointment) {
      await prisma.appointment.update({
        where: { id: appointment.id },
        data: {
          depositStatus: 'failed',
        },
      });
      console.log(`[Webhook] Deposit failed for appointment ${appointment.id}`);
    } else {
      // No appointment yet - payment failed before booking completed
      // User will see decline message in UI and can retry
      console.log(`[Webhook] Payment intent ${paymentIntent.id} failed, no appointment to update`);
    }
  } else {
    await prisma.payment.updateMany({
      where: { stripePaymentId: paymentIntent.id },
      data: { status: 'failed' },
    });
  }
  break;
}
```

5. Add handler for charge.refunded event:
```typescript
case 'charge.refunded': {
  const charge = event.data.object as any;
  const paymentIntentId = charge.payment_intent;

  if (paymentIntentId) {
    // Update appointment deposit status
    await prisma.appointment.updateMany({
      where: { stripePaymentIntentId: paymentIntentId },
      data: { depositStatus: 'refunded' },
    });

    // Update payment record
    await prisma.payment.updateMany({
      where: { stripePaymentId: paymentIntentId },
      data: {
        status: 'refunded',
        refundAmount: charge.amount_refunded / 100,
        refundedAt: new Date(),
      },
    });

    console.log(`[Webhook] Refund processed for payment intent ${paymentIntentId}`);
  }
  break;
}
```
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
Verify webhook handler imports checkAndMarkEventProcessed.
Verify idempotency check happens before processing.

**Webhook Registration Verification:**
Confirm Stripe webhook endpoint is configured to receive events. Either:
- Use Stripe CLI for local testing: `stripe listen --forward-to localhost:3001/api/v1/webhooks/stripe`
- OR verify in Stripe Dashboard (Developers -> Webhooks) that endpoint URL is registered with events:
  - payment_intent.succeeded
  - payment_intent.payment_failed
  - charge.refunded
If using Stripe CLI, run a test: `stripe trigger payment_intent.succeeded` and verify API logs show event received.
  </verify>
  <done>
Webhook handler uses idempotency service to prevent duplicate processing and handles deposit-related payment events. Webhook endpoint is registered with Stripe (or Stripe CLI is listening locally).
  </done>
</task>

</tasks>

<verification>
1. stripeHelpers.ts exists with calculateDepositCents, getDeclineMessage functions
2. payments.ts exports createDepositPaymentIntent function
3. webhooks.ts imports and uses checkAndMarkEventProcessed before processing events
4. Webhook handler updates appointment depositStatus on payment success/failure
5. API compiles without type errors: `pnpm --filter @peacase/api exec tsc --noEmit`
</verification>

<success_criteria>
- Payment intent creation uses manual capture method for deposits
- Webhook handler is idempotent (duplicate events are detected and skipped)
- Decline codes translate to user-friendly messages
- All payment events update relevant appointment records
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-processing/04-02-SUMMARY.md`
</output>
