---
phase: 04-payment-processing
plan: 04
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - apps/api/src/lib/refundHelper.ts
  - apps/api/src/routes/appointments.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/appointments/:id/cancel triggers refund when deposit exists and policy allows"
    - "Salon cancellation always triggers full refund"
    - "Client cancellation >24h in advance triggers full refund"
    - "Client cancellation <24h gets no automatic refund"
    - "Refund status updates on appointment and payment records"
  artifacts:
    - path: "apps/api/src/lib/refundHelper.ts"
      provides: "Refund policy logic and Stripe refund processing"
      exports: ["processAppointmentRefund", "RefundResult"]
    - path: "apps/api/src/routes/appointments.ts"
      provides: "Cancel endpoint with refund integration"
      contains: "processAppointmentRefund"
  key_links:
    - from: "apps/api/src/routes/appointments.ts"
      to: "apps/api/src/lib/refundHelper.ts"
      via: "import processAppointmentRefund"
      pattern: "processAppointmentRefund"
    - from: "apps/api/src/lib/refundHelper.ts"
      to: "stripe.refunds.create"
      via: "Stripe API call"
      pattern: "refunds\\.create"
---

<objective>
Implement refund flow for canceled appointments with time-based policy enforcement.

Purpose: When appointments are canceled, automatically process refunds according to business policy - full refund for salon cancellations or >24h notice, no auto-refund for late cancellations.
Output: Refund helper module with policy logic, updated appointment cancel endpoint.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-processing/04-RESEARCH.md
@.planning/phases/04-payment-processing/04-02-SUMMARY.md
@apps/api/src/routes/appointments.ts
@apps/api/src/services/payments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create refund helper with policy logic</name>
  <files>apps/api/src/lib/refundHelper.ts</files>
  <action>
Create the refund helper module that handles refund policy and Stripe integration:

```typescript
import { prisma } from '@peacase/database';
import { refundPayment, cancelPaymentIntent } from '../services/payments.js';

export interface RefundOptions {
  appointmentId: string;
  cancelledBy: 'client' | 'salon';
  reason?: string;
  requestedByUserId?: string;
}

export interface RefundResult {
  refunded: boolean;
  refundAmount: number;
  reason: string;
  requiresManualReview?: boolean;
}

/**
 * Default cancellation policy:
 * - Salon cancels: Full refund
 * - Client cancels >24h before: Full refund
 * - Client cancels <24h before: No automatic refund (can request manual review)
 */
const DEFAULT_POLICY = {
  fullRefundHours: 24,
};

/**
 * Calculate hours until appointment start time.
 */
function getHoursUntilAppointment(appointmentTime: Date): number {
  const now = new Date();
  const diffMs = appointmentTime.getTime() - now.getTime();
  return diffMs / (1000 * 60 * 60);
}

/**
 * Process refund for a canceled appointment based on cancellation policy.
 *
 * Policy:
 * 1. Salon cancels -> Always full refund (it's their fault)
 * 2. Client cancels >24h before -> Full refund
 * 3. Client cancels <24h before -> No automatic refund
 *
 * For payments not yet captured (manual capture mode), we cancel the payment intent
 * instead of issuing a refund.
 */
export async function processAppointmentRefund(options: RefundOptions): Promise<RefundResult> {
  // Fetch appointment with payment info
  const appointment = await prisma.appointment.findUnique({
    where: { id: options.appointmentId },
    include: {
      payments: {
        where: { status: 'completed' },
        orderBy: { createdAt: 'desc' },
        take: 1,
      },
      salon: true,
    },
  });

  if (!appointment) {
    throw new Error('Appointment not found');
  }

  // Check if there's a deposit to refund
  if (!appointment.stripePaymentIntentId && appointment.payments.length === 0) {
    return {
      refunded: false,
      refundAmount: 0,
      reason: 'No payment to refund',
    };
  }

  const paymentIntentId = appointment.stripePaymentIntentId;
  const payment = appointment.payments[0];
  const depositAmount = appointment.depositAmount || payment?.amount || 0;

  if (depositAmount <= 0) {
    return {
      refunded: false,
      refundAmount: 0,
      reason: 'No deposit amount recorded',
    };
  }

  // Determine if refund should be issued based on policy
  const hoursUntilAppointment = getHoursUntilAppointment(new Date(appointment.startTime));
  const policy = DEFAULT_POLICY;

  let shouldRefund = false;
  let refundReason = '';

  if (options.cancelledBy === 'salon') {
    // Salon canceled - always refund
    shouldRefund = true;
    refundReason = 'Cancelled by salon';
  } else if (hoursUntilAppointment >= policy.fullRefundHours) {
    // Client canceled with sufficient notice
    shouldRefund = true;
    refundReason = `Cancelled ${Math.floor(hoursUntilAppointment)}h before appointment`;
  } else {
    // Late cancellation - no automatic refund
    shouldRefund = false;
    refundReason = `Late cancellation (${Math.floor(hoursUntilAppointment)}h notice, policy requires ${policy.fullRefundHours}h)`;
  }

  if (shouldRefund && paymentIntentId) {
    try {
      // Check deposit status - if 'authorized' (not captured), cancel instead of refund
      if (appointment.depositStatus === 'authorized') {
        // Payment was authorized but not captured - cancel the payment intent
        await cancelPaymentIntent(paymentIntentId);

        // Update appointment
        await prisma.appointment.update({
          where: { id: options.appointmentId },
          data: {
            depositStatus: 'cancelled',
          },
        });

        // Update payment record if exists
        if (payment) {
          await prisma.payment.update({
            where: { id: payment.id },
            data: {
              status: 'cancelled',
              refundReason: options.reason || refundReason,
            },
          });
        }

        return {
          refunded: true,
          refundAmount: depositAmount,
          reason: 'Authorization cancelled (not charged)',
        };
      } else {
        // Payment was captured - issue refund
        const refund = await refundPayment(
          paymentIntentId,
          Math.round(depositAmount * 100), // Convert to cents
          options.cancelledBy === 'salon' ? 'requested_by_customer' : undefined
        );

        // Update appointment
        await prisma.appointment.update({
          where: { id: options.appointmentId },
          data: {
            depositStatus: 'refunded',
          },
        });

        // Update payment record
        if (payment) {
          await prisma.payment.update({
            where: { id: payment.id },
            data: {
              status: 'refunded',
              stripeRefundId: refund.id,
              refundAmount: depositAmount,
              refundReason: options.reason || refundReason,
              refundedAt: new Date(),
            },
          });
        }

        return {
          refunded: true,
          refundAmount: depositAmount,
          reason: refundReason,
        };
      }
    } catch (error: any) {
      console.error('[Refund] Error processing refund:', error);
      throw new Error(`Failed to process refund: ${error.message}`);
    }
  }

  // No refund - mark appointment appropriately
  await prisma.appointment.update({
    where: { id: options.appointmentId },
    data: {
      depositStatus: 'no_refund',
    },
  });

  return {
    refunded: false,
    refundAmount: 0,
    reason: refundReason,
    requiresManualReview: true,
  };
}
```
  </action>
  <verify>
Check file exists at apps/api/src/lib/refundHelper.ts.
Verify it exports processAppointmentRefund function.
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
  </verify>
  <done>
refundHelper.ts module created with policy-based refund logic that handles both authorization cancellation and captured payment refunds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update appointment cancel endpoint with refund integration</name>
  <files>apps/api/src/routes/appointments.ts</files>
  <action>
Update the cancel endpoint to process refunds when deposits exist:

1. Add import at top of file:
```typescript
import { processAppointmentRefund } from '../lib/refundHelper.js';
```

2. Update the POST /api/v1/appointments/:id/cancel handler to process refunds:

Find the existing cancel endpoint and replace it with:
```typescript
// ============================================
// POST /api/v1/appointments/:id/cancel
// Cancel appointment with refund processing
// ============================================
router.post(
  '/:id/cancel',
  authenticate,
  requirePermission(PERMISSIONS.CANCEL_APPOINTMENTS),
  asyncHandler(async (req: Request, res: Response) => {
    const appointment = await prisma.appointment.findFirst({
      where: { id: req.params.id, salonId: req.user!.salonId },
    });

    if (!appointment) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'NOT_FOUND',
          message: 'Appointment not found',
        },
      });
    }

    // Already cancelled?
    if (appointment.status === 'cancelled') {
      return res.status(400).json({
        success: false,
        error: {
          code: 'ALREADY_CANCELLED',
          message: 'Appointment is already cancelled',
        },
      });
    }

    const { cancellationReason, cancelledBy = 'salon' } = req.body;

    // Process refund if deposit exists
    let refundResult = null;
    if (appointment.stripePaymentIntentId || appointment.depositAmount) {
      try {
        refundResult = await processAppointmentRefund({
          appointmentId: req.params.id,
          cancelledBy: cancelledBy as 'client' | 'salon',
          reason: cancellationReason,
          requestedByUserId: req.user!.userId,
        });
      } catch (error: any) {
        console.error('[Cancel] Refund processing error:', error);
        // Don't block cancellation on refund failure - log and continue
      }
    }

    // Update appointment status
    const updated = await prisma.appointment.update({
      where: { id: req.params.id },
      data: {
        status: 'cancelled',
        cancellationReason,
        cancelledAt: new Date(),
      },
    });

    res.json({
      success: true,
      data: {
        appointment: updated,
        refund: refundResult,
      },
    });
  })
);
```

The key changes:
- Accept `cancelledBy` parameter ('client' | 'salon')
- Call processAppointmentRefund when payment exists
- Return refund result in response
- Don't block cancellation if refund fails (log error, continue)
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
Verify import of processAppointmentRefund exists.
Grep for "processAppointmentRefund" in appointments.ts to confirm integration.
  </verify>
  <done>
Cancel endpoint integrates refund processing, returns refund result, handles errors gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add capture payment intent endpoint for service completion</name>
  <files>apps/api/src/routes/appointments.ts</files>
  <action>
Add a new endpoint to capture the authorized payment when the service is completed:

```typescript
// Add import at top if not already present
import { capturePaymentIntent } from '../services/payments.js';

// Add after the cancel endpoint:

// ============================================
// POST /api/v1/appointments/:id/capture-payment
// Capture the authorized deposit (when service is rendered)
// ============================================
router.post(
  '/:id/capture-payment',
  authenticate,
  requirePermission(PERMISSIONS.EDIT_APPOINTMENTS),
  asyncHandler(async (req: Request, res: Response) => {
    const appointment = await prisma.appointment.findFirst({
      where: { id: req.params.id, salonId: req.user!.salonId },
    });

    if (!appointment) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'NOT_FOUND',
          message: 'Appointment not found',
        },
      });
    }

    if (!appointment.stripePaymentIntentId) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'NO_PAYMENT',
          message: 'No payment intent associated with this appointment',
        },
      });
    }

    if (appointment.depositStatus !== 'authorized') {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_STATUS',
          message: `Cannot capture payment with status: ${appointment.depositStatus}`,
        },
      });
    }

    try {
      // Capture the authorized payment
      const paymentIntent = await capturePaymentIntent(appointment.stripePaymentIntentId);

      // Update appointment
      await prisma.appointment.update({
        where: { id: req.params.id },
        data: {
          depositStatus: 'captured',
        },
      });

      // Update payment record
      await prisma.payment.updateMany({
        where: { stripePaymentId: appointment.stripePaymentIntentId },
        data: {
          status: 'captured',
        },
      });

      res.json({
        success: true,
        data: {
          captured: true,
          amount: paymentIntent.amount / 100,
        },
      });
    } catch (error: any) {
      console.error('[Capture] Error capturing payment:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'CAPTURE_FAILED',
          message: error.message || 'Failed to capture payment',
        },
      });
    }
  })
);
```
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
Grep for "capture-payment" in appointments.ts to confirm endpoint exists.

**Capture Flow End-to-End Verification:**
Test the complete capture flow to ensure deposits can be finalized:
1. Create a test appointment with stripePaymentIntentId (from booking flow)
2. Verify appointment has depositStatus: 'authorized'
3. Call POST /api/v1/appointments/:id/capture-payment with auth token
4. Verify response shows captured: true with correct amount
5. Check database: appointment.depositStatus should be 'captured'
6. Check database: payment.status should be 'captured'
7. Verify in Stripe Dashboard: Payment Intent status should be 'succeeded' (captured)

Test with curl:
```bash
# Get an appointment with authorized deposit
curl -H "Authorization: Bearer $TOKEN" \
  "http://localhost:3001/api/v1/appointments?depositStatus=authorized"

# Capture the payment
curl -X POST -H "Authorization: Bearer $TOKEN" \
  "http://localhost:3001/api/v1/appointments/{id}/capture-payment"
```
  </verify>
  <done>
Capture payment endpoint allows salon to finalize authorized deposits when service is completed. Capture flow verified end-to-end: authorize -> capture -> status updates in both appointment and payment records.
  </done>
</task>

</tasks>

<verification>
1. apps/api/src/lib/refundHelper.ts exists and exports processAppointmentRefund
2. Cancel endpoint calls processAppointmentRefund when deposit exists
3. Cancel endpoint accepts cancelledBy parameter ('client' | 'salon')
4. Capture payment endpoint exists at POST /:id/capture-payment
5. `pnpm --filter @peacase/api exec tsc --noEmit` passes
6. Existing tests still pass
</verification>

<success_criteria>
- Salon cancellation triggers automatic full refund
- Client cancellation >24h before triggers automatic full refund
- Client cancellation <24h before does NOT auto-refund (requiresManualReview: true)
- Authorized (uncaptured) payments are cancelled, not refunded
- Capture endpoint allows finalizing authorized deposits
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-processing/04-04-SUMMARY.md`
</output>
