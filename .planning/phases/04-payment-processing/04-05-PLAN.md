---
phase: 04-payment-processing
plan: 05
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - apps/api/src/routes/public.ts
  - apps/web/src/app/embed/[slug]/page.tsx
autonomous: false

must_haves:
  truths:
    - "Public booking API can create payment intent for deposits"
    - "Booking widget shows payment step when salon requires deposits"
    - "Successful payment creates appointment with deposit tracking"
    - "Payment decline shows retry option with friendly message"
  artifacts:
    - path: "apps/api/src/routes/public.ts"
      provides: "Public payment intent creation endpoint"
      contains: "create-payment-intent"
    - path: "apps/web/src/app/embed/[slug]/page.tsx"
      provides: "Booking widget with payment step"
      contains: "PaymentForm"
  key_links:
    - from: "apps/web/src/app/embed/[slug]/page.tsx"
      to: "apps/web/src/components/booking/PaymentForm.tsx"
      via: "import and render"
      pattern: "PaymentForm"
    - from: "apps/web/src/app/embed/[slug]/page.tsx"
      to: "POST /api/v1/public/:slug/create-payment-intent"
      via: "fetch call in usePayment"
      pattern: "create-payment-intent"
---

<objective>
Integrate payment flow into the public booking widget with full end-to-end deposit collection.

Purpose: Enable clients to pay deposits as part of the booking flow when salons require deposits.
Output: Public API endpoint for payment intents, updated booking widget with payment step.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-processing/04-RESEARCH.md
@.planning/phases/04-payment-processing/04-02-SUMMARY.md
@.planning/phases/04-payment-processing/04-03-SUMMARY.md
@apps/api/src/routes/public.ts
@apps/web/src/app/embed/[slug]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add public payment intent creation endpoint</name>
  <files>apps/api/src/routes/public.ts</files>
  <action>
Add a new public endpoint for creating payment intents:

1. Add import at top:
```typescript
import { createDepositPaymentIntent } from '../services/payments.js';
```

2. Add the endpoint (after the /book endpoint):
```typescript
// ============================================
// POST /api/v1/public/:slug/create-payment-intent
// Create a payment intent for booking deposit (public, unauthenticated)
// ============================================
router.post('/:slug/create-payment-intent', asyncHandler(async (req: Request, res: Response) => {
  const { slug } = req.params;
  const { serviceId, servicePrice, clientEmail, staffId, locationId, appointmentDate } = req.body;

  // Find salon by slug
  const salon = await prisma.salon.findUnique({
    where: { slug },
  });

  if (!salon) {
    return res.status(404).json({
      success: false,
      error: { code: 'NOT_FOUND', message: 'Salon not found' },
    });
  }

  // Check if salon requires deposits
  if (!salon.requireDeposit) {
    return res.status(400).json({
      success: false,
      error: { code: 'DEPOSITS_NOT_REQUIRED', message: 'This salon does not require deposits for booking' },
    });
  }

  // Validate required fields
  if (!serviceId || !servicePrice || !clientEmail || !appointmentDate) {
    return res.status(400).json({
      success: false,
      error: { code: 'MISSING_FIELDS', message: 'Missing required fields: serviceId, servicePrice, clientEmail, appointmentDate' },
    });
  }

  // Verify service exists and price matches (security: don't trust client-provided price)
  const service = await prisma.service.findFirst({
    where: { id: serviceId, salonId: salon.id, isActive: true },
  });

  if (!service) {
    return res.status(404).json({
      success: false,
      error: { code: 'SERVICE_NOT_FOUND', message: 'Service not found' },
    });
  }

  // Use server-side price, not client-provided
  const actualServicePrice = service.price;

  // Get or create client for this email
  let client = await prisma.client.findFirst({
    where: { email: clientEmail, salonId: salon.id },
  });

  if (!client) {
    // Will be created during booking, but we need an ID for metadata
    // For now, use a placeholder that will be updated when booking completes
    client = await prisma.client.create({
      data: {
        salonId: salon.id,
        email: clientEmail,
        firstName: 'Pending',
        lastName: 'Booking',
      },
    });
  }

  try {
    const { clientSecret, depositAmountCents } = await createDepositPaymentIntent({
      salonId: salon.id,
      serviceId,
      clientId: client.id,
      clientEmail,
      servicePrice: actualServicePrice,
      depositPercentage: salon.depositPercentage || 20,
      appointmentDate,
      staffId,
      locationId,
    });

    res.json({
      success: true,
      data: {
        clientSecret,
        depositAmountCents,
        servicePrice: actualServicePrice,
        depositPercentage: salon.depositPercentage || 20,
      },
    });
  } catch (error: any) {
    console.error('[Payment] Error creating payment intent:', error);
    res.status(500).json({
      success: false,
      error: { code: 'PAYMENT_ERROR', message: 'Failed to initialize payment' },
    });
  }
}));
```

Also update the /salon endpoint to include deposit settings in the response (so widget knows whether to show payment step):

Find the GET /:slug/salon endpoint and add deposit fields to the response:
```typescript
// In the existing salon response, add:
requireDeposit: salon.requireDeposit || false,
depositPercentage: salon.depositPercentage || 20,
```
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
Grep for "create-payment-intent" in public.ts to confirm endpoint exists.
  </verify>
  <done>
Public API has endpoint for creating payment intents, validates service price server-side, includes deposit settings in salon response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate payment into booking widget</name>
  <files>apps/web/src/app/embed/[slug]/page.tsx</files>
  <action>
Update the booking widget to include a payment step when deposits are required.

This is a substantial change to the existing file. Key modifications:

1. Add imports at top:
```typescript
import { Elements } from '@stripe/react-stripe-js';
import { PaymentForm } from '@/components/booking/PaymentForm';
import { BookingSummary } from '@/components/booking/BookingSummary';
import { getStripe } from '@/lib/stripe';
import { usePayment } from '@/hooks/usePayment';
```

2. Add to Salon interface:
```typescript
interface Salon {
  // ... existing fields
  requireDeposit?: boolean;
  depositPercentage?: number;
}
```

3. Add payment state variables in the main component:
```typescript
const [stripePromise] = useState(() => getStripe());
const [paymentClientSecret, setPaymentClientSecret] = useState<string | null>(null);
const [depositAmount, setDepositAmount] = useState<number>(0);
```

4. Update step numbering to include payment step when deposits required:
```typescript
// Determine if payment step is needed
const requiresDeposit = salon?.requireDeposit && !isDemo;

// Update step constants to conditionally include payment
const STEP_PAYMENT = requiresDeposit ? (hasMultipleLocations ? 6 : 5) : 0; // 0 = skip
const STEP_CONFIRM = requiresDeposit ? (hasMultipleLocations ? 7 : 6) : (hasMultipleLocations ? 6 : 5);
const totalSteps = requiresDeposit ? (hasMultipleLocations ? 7 : 6) : (hasMultipleLocations ? 6 : 5);
```

5. Add PaymentStep component within the file:
```typescript
function PaymentStep({
  clientSecret,
  depositAmount,
  servicePrice,
  serviceName,
  staffName,
  locationName,
  dateTime,
  onSuccess,
  primaryColor,
}: {
  clientSecret: string;
  depositAmount: number;
  servicePrice: number;
  serviceName: string;
  staffName?: string;
  locationName?: string;
  dateTime: string;
  onSuccess: () => void;
  primaryColor: string;
}) {
  const stripePromise = getStripe();

  return (
    <div className="space-y-6">
      <div className="text-center">
        <h2 className="text-xl font-bold text-gray-900">Secure Your Booking</h2>
        <p className="text-sm text-gray-500 mt-1">Pay your deposit to confirm your appointment</p>
      </div>

      <BookingSummary
        serviceName={serviceName}
        servicePrice={servicePrice}
        depositAmount={depositAmount}
        staffName={staffName}
        locationName={locationName}
        dateTime={dateTime}
        primaryColor={primaryColor}
      />

      <Elements
        stripe={stripePromise}
        options={{
          clientSecret,
          appearance: {
            theme: 'stripe',
            variables: {
              colorPrimary: primaryColor,
            },
          },
        }}
      >
        <PaymentForm onSuccess={onSuccess} primaryColor={primaryColor} />
      </Elements>
    </div>
  );
}
```

6. Update handleSubmit to create payment intent before moving to payment step:
```typescript
const handleSubmit = async () => {
  // ... existing validation ...

  if (requiresDeposit) {
    // Need to create payment intent and move to payment step
    setIsSubmitting(true);
    try {
      const response = await fetch(
        `${API_BASE}/api/v1/public/${slug}/create-payment-intent`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            serviceId: booking.serviceId,
            servicePrice: /* get from selected service */,
            clientEmail: booking.email,
            staffId: booking.staffId,
            locationId: booking.locationId,
            appointmentDate: `${booking.date}T${booking.time}:00`,
          }),
        }
      );
      const data = await response.json();
      if (data.success) {
        setPaymentClientSecret(data.data.clientSecret);
        setDepositAmount(data.data.depositAmountCents / 100);
        setStep(STEP_PAYMENT);
      } else {
        setError(data.error?.message || 'Failed to initialize payment');
      }
    } finally {
      setIsSubmitting(false);
    }
    return;
  }

  // ... rest of existing handleSubmit for non-deposit flow ...
};
```

7. Add payment step rendering in the main content area:
```typescript
{step === STEP_PAYMENT && paymentClientSecret && (
  <PaymentStep
    clientSecret={paymentClientSecret}
    depositAmount={depositAmount}
    servicePrice={/* from selected service */}
    serviceName={booking.serviceName || ''}
    staffName={booking.staffName || undefined}
    locationName={booking.locationName || undefined}
    dateTime={formatDateTime()}
    onSuccess={handlePaymentSuccess}
    primaryColor={primaryColor}
  />
)}
```

8. Add handlePaymentSuccess function:
```typescript
const handlePaymentSuccess = async () => {
  // Payment successful, now create the actual booking
  const startTime = `${booking.date}T${booking.time}:00`;
  const result = await createBooking(slug, {
    serviceId: booking.serviceId!,
    staffId: booking.staffId || undefined,
    locationId: booking.locationId || undefined,
    startTime,
    firstName: booking.firstName,
    lastName: booking.lastName,
    email: booking.email,
    phone: booking.phone || undefined,
    notes: booking.notes || undefined,
    optInReminders: booking.optInReminders,
    paymentIntentId: paymentClientSecret, // Link payment to booking
  });

  if (result.success) {
    setStep(STEP_CONFIRM);
    window.parent?.postMessage({ type: 'peacase-booking-complete' }, '*');
  } else {
    setError(result.error?.message || 'Failed to create booking');
  }
};
```

NOTE: This is a complex integration. Ensure:
- Stripe Elements provider wraps PaymentForm correctly
- Client secret is passed to Elements options
- Step navigation handles the new payment step
- Non-deposit flow continues to work as before
  </action>
  <verify>
Run `pnpm --filter @peacase/web exec tsc --noEmit` - should compile.
Check file imports PaymentForm, BookingSummary, Elements from Stripe.
  </verify>
  <done>
Booking widget includes payment step when salon requires deposits, integrates with Stripe Payment Element.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete end-to-end payment flow:
1. Public API endpoint for creating payment intents
2. Booking widget with payment step
3. Stripe Payment Element integration
4. Deposit collection during booking
  </what-built>
  <how-to-verify>
1. **Test with a test salon that has deposits enabled:**
   - Set `requireDeposit: true` on a test salon in the database
   - Open the booking widget: http://localhost:3000/embed/{salon-slug}

2. **Walk through booking flow:**
   - Select service, staff, date/time
   - Enter client details
   - Should see payment step with BookingSummary showing deposit amount

3. **Test successful payment:**
   - Use Stripe test card: 4242 4242 4242 4242
   - Any future expiry, any CVC
   - Should complete and show confirmation

4. **Test declined payment:**
   - Use Stripe decline test card: 4000 0000 0000 0002
   - Should show user-friendly decline message
   - Should have retry option

5. **Verify in Stripe Dashboard:**
   - Log into Stripe Dashboard (test mode)
   - Check Payment Intents - should see new payment with status "requires_capture" or "succeeded"
   - Metadata should include salonId, serviceId, etc.

6. **Test non-deposit flow still works:**
   - Use a salon WITHOUT deposits enabled
   - Should skip payment step and book directly
  </how-to-verify>
  <resume-signal>Type "approved" if payment flow works, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. GET /api/v1/public/:slug/salon returns requireDeposit and depositPercentage fields
2. POST /api/v1/public/:slug/create-payment-intent creates Payment Intent with manual capture
3. Booking widget shows payment step when salon.requireDeposit is true
4. PaymentForm renders Stripe Payment Element
5. Successful payment leads to booking creation
6. Declined payment shows friendly error with retry option
7. Non-deposit salons skip payment step
</verification>

<success_criteria>
- End-to-end deposit collection works in booking widget
- Payment intents created with correct metadata
- Decline messages are user-friendly
- Retry functionality works
- Non-deposit flow unaffected
- Payment appears in Stripe Dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-processing/04-05-SUMMARY.md`
</output>
