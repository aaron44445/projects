---
phase: 04-payment-processing
plan: 05
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - apps/api/src/routes/public.ts
  - apps/web/src/app/embed/[slug]/page.tsx
autonomous: false

must_haves:
  truths:
    - "Public booking API can create payment intent for deposits"
    - "Booking widget shows payment step when salon requires deposits"
    - "Successful payment creates appointment with deposit tracking"
    - "Payment decline shows retry option with friendly message"
  artifacts:
    - path: "apps/api/src/routes/public.ts"
      provides: "Public payment intent creation endpoint"
      contains: "create-payment-intent"
    - path: "apps/web/src/app/embed/[slug]/page.tsx"
      provides: "Booking widget with payment step"
      contains: "PaymentForm"
  key_links:
    - from: "apps/web/src/app/embed/[slug]/page.tsx"
      to: "apps/web/src/components/booking/PaymentForm.tsx"
      via: "import and render"
      pattern: "PaymentForm"
    - from: "apps/web/src/app/embed/[slug]/page.tsx"
      to: "POST /api/v1/public/:slug/create-payment-intent"
      via: "fetch call in handleSubmit"
      pattern: "create-payment-intent"
    - from: "apps/web/src/components/booking/PaymentForm.tsx"
      to: "onSuccess callback"
      via: "passes paymentIntent.id (NOT clientSecret) after confirmPayment succeeds"
      pattern: "onSuccess\\(paymentIntent\\.id\\)"
    - from: "apps/web/src/app/embed/[slug]/page.tsx"
      to: "POST /api/v1/public/:slug/book"
      via: "createBooking passes stripePaymentIntentId to link payment to appointment"
      pattern: "stripePaymentIntentId"
---

<objective>
Integrate payment flow into the public booking widget with full end-to-end deposit collection.

Purpose: Enable clients to pay deposits as part of the booking flow when salons require deposits.
Output: Public API endpoint for payment intents, updated booking widget with payment step.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-processing/04-RESEARCH.md
@.planning/phases/04-payment-processing/04-02-SUMMARY.md
@.planning/phases/04-payment-processing/04-03-SUMMARY.md
@apps/api/src/routes/public.ts
@apps/web/src/app/embed/[slug]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add public payment intent creation endpoint</name>
  <files>apps/api/src/routes/public.ts</files>
  <action>
Add a new public endpoint for creating payment intents:

1. Add import at top:
```typescript
import { createDepositPaymentIntent } from '../services/payments.js';
```

2. Add the endpoint (after the /book endpoint):
```typescript
// ============================================
// POST /api/v1/public/:slug/create-payment-intent
// Create a payment intent for booking deposit (public, unauthenticated)
// ============================================
router.post('/:slug/create-payment-intent', asyncHandler(async (req: Request, res: Response) => {
  const { slug } = req.params;
  const { serviceId, servicePrice, clientEmail, staffId, locationId, appointmentDate } = req.body;

  // Find salon by slug
  const salon = await prisma.salon.findUnique({
    where: { slug },
  });

  if (!salon) {
    return res.status(404).json({
      success: false,
      error: { code: 'NOT_FOUND', message: 'Salon not found' },
    });
  }

  // Check if salon requires deposits
  if (!salon.requireDeposit) {
    return res.status(400).json({
      success: false,
      error: { code: 'DEPOSITS_NOT_REQUIRED', message: 'This salon does not require deposits for booking' },
    });
  }

  // Validate required fields
  if (!serviceId || !servicePrice || !clientEmail || !appointmentDate) {
    return res.status(400).json({
      success: false,
      error: { code: 'MISSING_FIELDS', message: 'Missing required fields: serviceId, servicePrice, clientEmail, appointmentDate' },
    });
  }

  // Verify service exists and price matches (security: don't trust client-provided price)
  const service = await prisma.service.findFirst({
    where: { id: serviceId, salonId: salon.id, isActive: true },
  });

  if (!service) {
    return res.status(404).json({
      success: false,
      error: { code: 'SERVICE_NOT_FOUND', message: 'Service not found' },
    });
  }

  // Use server-side price, not client-provided
  const actualServicePrice = service.price;

  // Get or create client for this email
  let client = await prisma.client.findFirst({
    where: { email: clientEmail, salonId: salon.id },
  });

  if (!client) {
    // Will be created during booking, but we need an ID for metadata
    // For now, use a placeholder that will be updated when booking completes
    client = await prisma.client.create({
      data: {
        salonId: salon.id,
        email: clientEmail,
        firstName: 'Pending',
        lastName: 'Booking',
      },
    });
  }

  try {
    const { clientSecret, depositAmountCents } = await createDepositPaymentIntent({
      salonId: salon.id,
      serviceId,
      clientId: client.id,
      clientEmail,
      servicePrice: actualServicePrice,
      depositPercentage: salon.depositPercentage || 20,
      appointmentDate,
      staffId,
      locationId,
    });

    res.json({
      success: true,
      data: {
        clientSecret,
        depositAmountCents,
        servicePrice: actualServicePrice,
        depositPercentage: salon.depositPercentage || 20,
      },
    });
  } catch (error: any) {
    console.error('[Payment] Error creating payment intent:', error);
    res.status(500).json({
      success: false,
      error: { code: 'PAYMENT_ERROR', message: 'Failed to initialize payment' },
    });
  }
}));
```

Also update the /salon endpoint to include deposit settings in the response (so widget knows whether to show payment step):

Find the GET /:slug/salon endpoint and add deposit fields to the response:
```typescript
// In the existing salon response, add:
requireDeposit: salon.requireDeposit || false,
depositPercentage: salon.depositPercentage || 20,
```

**CRITICAL: Update the existing POST /:slug/book endpoint to accept stripePaymentIntentId.**

This links the payment to the appointment so webhooks can find it later. Find the /book endpoint and add:

1. Add to request body destructuring:
```typescript
const {
  serviceId, staffId, locationId, startTime,
  firstName, lastName, email, phone, notes, optInReminders,
  stripePaymentIntentId  // Add this - optional, only passed when deposit paid
} = req.body;
```

2. When creating the appointment, add the stripePaymentIntentId field:
```typescript
const appointment = await prisma.appointment.create({
  data: {
    // ... existing fields ...
    stripePaymentIntentId: stripePaymentIntentId || null,  // Link to payment
    depositStatus: stripePaymentIntentId ? 'authorized' : null,  // Set initial status
    // Note: depositAmount will be updated by webhook with exact amount from Stripe
  },
});
```

This ensures the webhook handler can find and update the appointment via `prisma.appointment.findFirst({ where: { stripePaymentIntentId } })`.
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should compile.
Grep for "create-payment-intent" in public.ts to confirm endpoint exists.
Grep for "stripePaymentIntentId" in public.ts to confirm booking endpoint accepts payment intent ID.
  </verify>
  <done>
Public API has endpoint for creating payment intents, booking endpoint accepts stripePaymentIntentId to link payments to appointments, includes deposit settings in salon response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate payment into booking widget</name>
  <files>apps/web/src/app/embed/[slug]/page.tsx</files>
  <action>
Update the booking widget to include a payment step when deposits are required.

This is a substantial change to the existing file. Key modifications:

1. Add imports at top:
```typescript
import { Elements } from '@stripe/react-stripe-js';
import { PaymentForm } from '@/components/booking/PaymentForm';
import { BookingSummary } from '@/components/booking/BookingSummary';
import { getStripe } from '@/lib/stripe';
import { usePayment } from '@/hooks/usePayment';
```

2. Add to Salon interface:
```typescript
interface Salon {
  // ... existing fields
  requireDeposit?: boolean;
  depositPercentage?: number;
}
```

3. Add payment state variables in the main component:
```typescript
const [stripePromise] = useState(() => getStripe());
const [paymentClientSecret, setPaymentClientSecret] = useState<string | null>(null);
const [depositAmount, setDepositAmount] = useState<number>(0);
```

4. Update step numbering to include payment step when deposits required:
```typescript
// Determine if payment step is needed
const requiresDeposit = salon?.requireDeposit && !isDemo;

// Update step constants to conditionally include payment
const STEP_PAYMENT = requiresDeposit ? (hasMultipleLocations ? 6 : 5) : 0; // 0 = skip
const STEP_CONFIRM = requiresDeposit ? (hasMultipleLocations ? 7 : 6) : (hasMultipleLocations ? 6 : 5);
const totalSteps = requiresDeposit ? (hasMultipleLocations ? 7 : 6) : (hasMultipleLocations ? 6 : 5);
```

5. Add PaymentStep component within the file:
```typescript
function PaymentStep({
  clientSecret,
  depositAmount,
  servicePrice,
  serviceName,
  staffName,
  locationName,
  dateTime,
  onSuccess,
  primaryColor,
}: {
  clientSecret: string;
  depositAmount: number;
  servicePrice: number;
  serviceName: string;
  staffName?: string;
  locationName?: string;
  dateTime: string;
  onSuccess: () => void;
  primaryColor: string;
}) {
  const stripePromise = getStripe();

  return (
    <div className="space-y-6">
      <div className="text-center">
        <h2 className="text-xl font-bold text-gray-900">Secure Your Booking</h2>
        <p className="text-sm text-gray-500 mt-1">Pay your deposit to confirm your appointment</p>
      </div>

      <BookingSummary
        serviceName={serviceName}
        servicePrice={servicePrice}
        depositAmount={depositAmount}
        staffName={staffName}
        locationName={locationName}
        dateTime={dateTime}
        primaryColor={primaryColor}
      />

      <Elements
        stripe={stripePromise}
        options={{
          clientSecret,
          appearance: {
            theme: 'stripe',
            variables: {
              colorPrimary: primaryColor,
            },
          },
        }}
      >
        <PaymentForm onSuccess={onSuccess} primaryColor={primaryColor} />
      </Elements>
    </div>
  );
}
```

6. Update handleSubmit to create payment intent before moving to payment step.

**State setup:** The booking widget already tracks selected service in state. Add a derived variable to get the selected service's price:

```typescript
// Near other state declarations, add selectedService derived value:
const selectedService = services?.find(s => s.id === booking.serviceId);
const selectedServicePrice = selectedService?.price || 0;
```

**Update handleSubmit:**
```typescript
const handleSubmit = async () => {
  // ... existing validation ...

  if (requiresDeposit) {
    // Need to create payment intent and move to payment step
    setIsSubmitting(true);
    try {
      const response = await fetch(
        `${API_BASE}/api/v1/public/${slug}/create-payment-intent`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            serviceId: booking.serviceId,
            servicePrice: selectedServicePrice, // From derived state: services.find(s => s.id === booking.serviceId)?.price
            clientEmail: booking.email,
            staffId: booking.staffId,
            locationId: booking.locationId,
            appointmentDate: `${booking.date}T${booking.time}:00`,
          }),
        }
      );
      const data = await response.json();
      if (data.success) {
        setPaymentClientSecret(data.data.clientSecret);
        setDepositAmount(data.data.depositAmountCents / 100);
        setStep(STEP_PAYMENT);
      } else {
        setError(data.error?.message || 'Failed to initialize payment');
      }
    } finally {
      setIsSubmitting(false);
    }
    return;
  }

  // ... rest of existing handleSubmit for non-deposit flow ...
};
```

7. Add payment step rendering in the main content area:
```typescript
{step === STEP_PAYMENT && paymentClientSecret && (
  <PaymentStep
    clientSecret={paymentClientSecret}
    depositAmount={depositAmount}
    servicePrice={selectedServicePrice} // From derived state (see step 6)
    serviceName={booking.serviceName || ''}
    staffName={booking.staffName || undefined}
    locationName={booking.locationName || undefined}
    dateTime={formatDateTime()}
    onSuccess={handlePaymentSuccess}
    primaryColor={primaryColor}
  />
)}
```

8. Add handlePaymentSuccess function.

**CRITICAL:** The Stripe `confirmPayment` response returns a `paymentIntent` object. Extract `paymentIntent.id` (format: `pi_xxx`) to pass to the booking API. Do NOT pass the `clientSecret` (format: `pi_xxx_secret_yyy`) - that's for client-side authentication only.

```typescript
const handlePaymentSuccess = async (paymentIntentId: string) => {
  // Payment successful, now create the actual booking
  // IMPORTANT: paymentIntentId comes from confirmPayment result, e.g., paymentIntent.id
  // This is NOT the clientSecret - clientSecret is for client-side auth only

  // VERIFICATION: Log the payment intent ID to confirm format before calling createBooking
  // Expected format: 'pi_xxx' (e.g., 'pi_3N7qHt2eZvKYlo2C0FdPz9Xe')
  // If this logs something like 'pi_xxx_secret_yyy', PaymentForm is incorrectly passing clientSecret
  console.log('[handlePaymentSuccess] Received paymentIntentId:', paymentIntentId);
  if (!paymentIntentId.startsWith('pi_') || paymentIntentId.includes('_secret_')) {
    console.error('[handlePaymentSuccess] INVALID: Expected payment intent ID (pi_xxx), got:', paymentIntentId);
    setError('Payment processing error. Please try again.');
    return;
  }

  const startTime = `${booking.date}T${booking.time}:00`;
  const result = await createBooking(slug, {
    serviceId: booking.serviceId!,
    staffId: booking.staffId || undefined,
    locationId: booking.locationId || undefined,
    startTime,
    firstName: booking.firstName,
    lastName: booking.lastName,
    email: booking.email,
    phone: booking.phone || undefined,
    notes: booking.notes || undefined,
    optInReminders: booking.optInReminders,
    stripePaymentIntentId: paymentIntentId, // Link payment to appointment via payment intent ID
  });

  if (result.success) {
    setStep(STEP_CONFIRM);
    window.parent?.postMessage({ type: 'peacase-booking-complete' }, '*');
  } else {
    setError(result.error?.message || 'Failed to create booking');
  }
};
```

**In PaymentForm.tsx (from 04-03), the onSuccess callback must pass the paymentIntent.id:**

```typescript
// In PaymentForm.tsx handleSubmit:
const { error, paymentIntent } = await stripe.confirmPayment({
  elements,
  confirmParams: {
    return_url: window.location.href, // Fallback for redirect-based payments
  },
  redirect: 'if_required',
});

if (error) {
  setErrorMessage(getDeclineMessage(error.decline_code || error.code));
  setIsProcessing(false);
} else if (paymentIntent && paymentIntent.status === 'requires_capture') {
  // Manual capture mode - payment authorized, not captured yet
  onSuccess(paymentIntent.id); // Pass the payment intent ID, NOT the client secret
} else if (paymentIntent && paymentIntent.status === 'succeeded') {
  // Some payment methods capture immediately
  onSuccess(paymentIntent.id);
}
```

NOTE: This is a complex integration. Ensure:
- Stripe Elements provider wraps PaymentForm correctly
- Client secret is passed to Elements options
- Step navigation handles the new payment step
- Non-deposit flow continues to work as before
  </action>
  <verify>
Run `pnpm --filter @peacase/web exec tsc --noEmit` - should compile.
Check file imports PaymentForm, BookingSummary, Elements from Stripe.

**Payment Intent ID Verification:**
After completing a test booking with payment:
1. Check browser console for: `[handlePaymentSuccess] Received paymentIntentId: pi_xxx`
   - Confirm format is `pi_xxx` (NOT `pi_xxx_secret_yyy`)
   - If format is wrong, PaymentForm.tsx is passing clientSecret instead of paymentIntent.id
2. Query database for the created appointment:
   ```sql
   SELECT id, stripePaymentIntentId FROM Appointment
   ORDER BY createdAt DESC LIMIT 1;
   ```
3. Verify stripePaymentIntentId matches what Stripe Dashboard shows for the Payment Intent
4. Verify the format matches exactly: `pi_` prefix, no `_secret_` suffix
  </verify>
  <done>
Booking widget includes payment step when salon requires deposits, integrates with Stripe Payment Element. Payment intent ID correctly passed from PaymentForm to handlePaymentSuccess to createBooking API.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete end-to-end payment flow:
1. Public API endpoint for creating payment intents
2. Booking widget with payment step
3. Stripe Payment Element integration
4. Deposit collection during booking
  </what-built>
  <how-to-verify>
1. **Test with a test salon that has deposits enabled:**
   - Set `requireDeposit: true` on a test salon in the database
   - Open the booking widget: http://localhost:3000/embed/{salon-slug}

2. **Walk through booking flow:**
   - Select service, staff, date/time
   - Enter client details
   - Should see payment step with BookingSummary showing deposit amount

3. **Test successful payment:**
   - Use Stripe test card: 4242 4242 4242 4242
   - Any future expiry, any CVC
   - Should complete and show confirmation

4. **Test declined payment:**
   - Use Stripe decline test card: 4000 0000 0000 0002
   - Should show user-friendly decline message
   - Should have retry option

5. **Verify in Stripe Dashboard:**
   - Log into Stripe Dashboard (test mode)
   - Check Payment Intents - should see new payment with status "requires_capture" or "succeeded"
   - Metadata should include salonId, serviceId, etc.

6. **Test non-deposit flow still works:**
   - Use a salon WITHOUT deposits enabled
   - Should skip payment step and book directly

7. **Verify webhook timing (Success Criterion 3: payment status updates within 60 seconds):**
   - After successful payment, check appointment in database immediately
   - Verify stripePaymentIntentId is set on the appointment
   - Wait for webhook to fire (usually <5 seconds in test mode with Stripe CLI)
   - Verify depositStatus is updated to 'authorized'
   - If using Stripe CLI: `stripe listen --forward-to localhost:3001/api/v1/webhooks/stripe`
   - Check webhook logs to confirm processing time
   - Open calendar view and confirm deposit indicator shows on the appointment
  </how-to-verify>
  <resume-signal>Type "approved" if payment flow works, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. GET /api/v1/public/:slug/salon returns requireDeposit and depositPercentage fields
2. POST /api/v1/public/:slug/create-payment-intent creates Payment Intent with manual capture
3. Booking widget shows payment step when salon.requireDeposit is true
4. PaymentForm renders Stripe Payment Element
5. Successful payment leads to booking creation with stripePaymentIntentId stored on appointment
6. Declined payment shows friendly error with retry option
7. Non-deposit salons skip payment step
8. Webhook updates appointment depositStatus within 60 seconds of payment completion
</verification>

<success_criteria>
- End-to-end deposit collection works in booking widget
- Payment intents created with correct metadata
- Booking stores stripePaymentIntentId to link payment to appointment
- Webhook can find appointment by stripePaymentIntentId and update depositStatus
- Payment status updates appear on appointments within 60 seconds (Success Criterion 3)
- Decline messages are user-friendly
- Retry functionality works
- Non-deposit flow unaffected
- Payment appears in Stripe Dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-processing/04-05-SUMMARY.md`
</output>
