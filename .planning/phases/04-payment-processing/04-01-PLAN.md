---
phase: 04-payment-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - apps/api/src/services/webhookEvents.ts
autonomous: true

must_haves:
  truths:
    - "WebhookEvent model exists in database with unique constraint on stripeEventId"
    - "Salon model has depositPercentage and requireDeposit fields"
    - "Appointment model has depositAmount, depositStatus, and stripePaymentIntentId fields"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "WebhookEvent model, Salon deposit fields, Appointment payment fields"
      contains: "model WebhookEvent"
    - path: "apps/api/src/services/webhookEvents.ts"
      provides: "Idempotency service for webhook event tracking"
      exports: ["checkEventProcessed", "markEventProcessed"]
  key_links:
    - from: "apps/api/src/services/webhookEvents.ts"
      to: "prisma.webhookEvent"
      via: "database queries"
      pattern: "prisma\\.webhookEvent"
---

<objective>
Add database schema for webhook idempotency tracking and payment-related fields.

Purpose: Foundation for reliable payment processing - idempotent webhooks prevent duplicate charges, deposit fields on models enable deposit tracking.
Output: Updated Prisma schema with WebhookEvent model and payment-related fields on Salon and Appointment.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-processing/04-RESEARCH.md
@packages/database/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebhookEvent model and update Salon/Appointment models</name>
  <files>packages/database/prisma/schema.prisma</files>
  <action>
Add WebhookEvent model for idempotency tracking:

```prisma
model WebhookEvent {
  id            String   @id @default(uuid())
  stripeEventId String   @unique @map("stripe_event_id")
  eventType     String   @map("event_type")
  processedAt   DateTime @default(now()) @map("processed_at")

  @@index([stripeEventId])
  @@map("webhook_events")
}
```

Add fields to Salon model (after existing fields):
- depositPercentage Int @default(20) @map("deposit_percentage")
- requireDeposit Boolean @default(false) @map("require_deposit")
- cancellationPolicy String @default("{}") @map("cancellation_policy")

Add fields to Appointment model (after existing price field):
- depositAmount Float? @map("deposit_amount")
- depositStatus String? @map("deposit_status")
- stripePaymentIntentId String? @map("stripe_payment_intent_id")

NOTE: Use snake_case for column names (@map decorator) to match existing convention.
  </action>
  <verify>
Run `pnpm --filter @peacase/database exec prisma validate` - should pass without errors.
Grep for "WebhookEvent" and "depositAmount" in schema.prisma to confirm fields exist.
  </verify>
  <done>
Schema includes WebhookEvent model, Salon has deposit configuration fields, Appointment has payment tracking fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook events idempotency service</name>
  <files>apps/api/src/services/webhookEvents.ts</files>
  <action>
Create a new service file that provides idempotent webhook event tracking:

```typescript
import { prisma } from '@peacase/database';

/**
 * Check if a webhook event has already been processed.
 * Uses database unique constraint for race-condition safety.
 *
 * @param stripeEventId - The Stripe event ID (e.g., "evt_xxx")
 * @param eventType - The event type (e.g., "payment_intent.succeeded")
 * @returns true if event was already processed, false if this is the first processing
 */
export async function checkAndMarkEventProcessed(
  stripeEventId: string,
  eventType: string
): Promise<{ alreadyProcessed: boolean }> {
  try {
    await prisma.webhookEvent.create({
      data: {
        stripeEventId,
        eventType,
      },
    });
    return { alreadyProcessed: false };
  } catch (error: any) {
    // Unique constraint violation = already processed
    if (error.code === 'P2002') {
      console.log(`[Webhook] Event ${stripeEventId} already processed, skipping`);
      return { alreadyProcessed: true };
    }
    // Re-throw other errors
    throw error;
  }
}

/**
 * Check if an event was processed (without marking it).
 * Useful for debugging and manual queries.
 */
export async function wasEventProcessed(stripeEventId: string): Promise<boolean> {
  const event = await prisma.webhookEvent.findUnique({
    where: { stripeEventId },
  });
  return event !== null;
}
```

Export both functions. Add JSDoc comments explaining the idempotency pattern.
  </action>
  <verify>
Run `pnpm --filter @peacase/api exec tsc --noEmit` - should pass type checking.
Check file exists and exports checkAndMarkEventProcessed function.
  </verify>
  <done>
webhookEvents.ts service exists with idempotency functions that use database unique constraint for race-safe duplicate detection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run Prisma migration and generate client</name>
  <files>packages/database/prisma/schema.prisma</files>
  <action>
Push the schema changes to the database and regenerate the Prisma client:

1. Run `pnpm --filter @peacase/database exec prisma db push` to apply schema changes
2. Run `pnpm --filter @peacase/database exec prisma generate` to regenerate client
3. Run `pnpm --filter @peacase/database build` to rebuild the package

If db push fails due to connection issues, check DATABASE_URL in .env. If it fails due to conflicts, use `--accept-data-loss` flag (only for dev, safe since we're adding new fields/tables not modifying existing).

NOTE: These are additive changes (new model + new nullable fields), so no data loss expected.
  </action>
  <verify>
Run `pnpm --filter @peacase/database exec prisma db push` - should succeed.
Run `pnpm --filter @peacase/api exec tsc --noEmit` - API should compile with new types.
Import { WebhookEvent } from '@peacase/database' in a test file to verify type is generated.
  </verify>
  <done>
Database schema updated, Prisma client regenerated with WebhookEvent type and updated Salon/Appointment types.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @peacase/database exec prisma validate` passes
2. WebhookEvent model exists in schema with unique stripeEventId
3. Salon model has depositPercentage (Int, default 20) and requireDeposit (Boolean, default false)
4. Appointment model has depositAmount (Float?), depositStatus (String?), stripePaymentIntentId (String?)
5. webhookEvents.ts exports checkAndMarkEventProcessed function
6. API compiles without type errors
</verification>

<success_criteria>
- Schema changes applied to database without errors
- Prisma client regenerated with new types
- Idempotency service ready for webhook handlers
- All existing tests still pass (new fields are optional/have defaults)
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-processing/04-01-SUMMARY.md`
</output>
