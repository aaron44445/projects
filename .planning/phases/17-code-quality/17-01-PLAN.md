---
phase: 17-code-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/lib/logger.ts
  - apps/api/src/lib/prismaUtils.ts
  - apps/api/package.json
autonomous: true

must_haves:
  truths:
    - "Logger module exports default pino logger instance"
    - "Logger uses JSON format in production, pretty-print in development"
    - "withSalonId utility returns typed { salonId: string } object"
    - "Pino and pino-http are installed as dependencies"
  artifacts:
    - path: "apps/api/src/lib/logger.ts"
      provides: "Structured JSON logger"
      exports: ["default"]
      contains: "pino"
    - path: "apps/api/src/lib/prismaUtils.ts"
      provides: "Tenant filter utility"
      exports: ["withSalonId"]
  key_links:
    - from: "apps/api/src/lib/logger.ts"
      to: "pino"
      via: "import"
      pattern: "import pino from 'pino'"
---

<objective>
Create foundation utilities for Code Quality phase: structured logger and salonId filter utility.

Purpose: Establishes the shared infrastructure that all route files will import. Without these utilities, subsequent plans cannot proceed.
Output: Two new lib files (logger.ts, prismaUtils.ts) and pino dependencies installed.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-code-quality/17-RESEARCH.md
@apps/api/src/lib/errorUtils.ts
@apps/api/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Pino dependencies</name>
  <files>apps/api/package.json</files>
  <action>
Install pino and pino-http as production dependencies, pino-pretty as dev dependency:
```bash
cd apps/api && npm install pino pino-http && npm install --save-dev pino-pretty
```

Verify packages are added to package.json with correct versions (pino ^9.x, pino-http ^10.x, pino-pretty ^12.x).
  </action>
  <verify>
```bash
cd apps/api && npm ls pino pino-http pino-pretty
```
All three packages should be listed without errors.
  </verify>
  <done>package.json includes pino, pino-http as dependencies and pino-pretty as devDependency</done>
</task>

<task type="auto">
  <name>Task 2: Create logger.ts with Pino configuration</name>
  <files>apps/api/src/lib/logger.ts</files>
  <action>
Create `apps/api/src/lib/logger.ts` with this exact implementation:

```typescript
import pino from 'pino';

const isDevelopment = process.env.NODE_ENV === 'development';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  timestamp: pino.stdTimeFunctions.isoTime,
  formatters: {
    level: (label) => ({ level: label }),
  },
  transport: isDevelopment ? {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'HH:MM:ss.l',
      ignore: 'pid,hostname',
    }
  } : undefined,
});

export default logger;
```

Key design decisions (from RESEARCH.md):
- JSON format in production (no transport) for log aggregators
- pino-pretty only in development (NODE_ENV check)
- ISO timestamp format for consistency
- LOG_LEVEL env var for runtime control
- Simple level formatter for cleaner JSON
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/lib/logger.ts
```
TypeScript compilation should pass with no errors.
  </verify>
  <done>logger.ts exports default pino instance, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 3: Create prismaUtils.ts with withSalonId utility</name>
  <files>apps/api/src/lib/prismaUtils.ts</files>
  <action>
Create `apps/api/src/lib/prismaUtils.ts` with this implementation:

```typescript
/**
 * Prisma utility functions for type-safe queries.
 *
 * These utilities provide explicit typing for common query patterns,
 * replacing implicit `any` types in route handlers.
 */

/**
 * Creates a Prisma where clause that filters by salonId.
 * Use this in all multi-tenant queries to ensure tenant isolation.
 *
 * @param salonId - The salon ID to filter by
 * @returns Typed filter object for Prisma where clause
 *
 * @example
 * const where = {
 *   ...withSalonId(req.user!.salonId),
 *   status: 'confirmed',
 * } satisfies Prisma.AppointmentWhereInput;
 */
export function withSalonId(salonId: string): { salonId: string } {
  return { salonId };
}
```

Design decisions (from CONTEXT.md):
- Simple function, not magical middleware
- Explicit return type for type safety
- Composable via spread operator
- Clear JSDoc for usage pattern
- Does NOT depend on Prisma types (keeps it simple, works with any model)
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/lib/prismaUtils.ts
```
TypeScript compilation should pass with no errors.
  </verify>
  <done>prismaUtils.ts exports withSalonId function that returns { salonId: string }</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm ls pino` shows pino installed
2. `apps/api/src/lib/logger.ts` exists and exports default
3. `apps/api/src/lib/prismaUtils.ts` exists and exports withSalonId
4. `cd apps/api && npm run build` passes (or `npx tsc --noEmit`)
</verification>

<success_criteria>
- Pino dependencies installed in apps/api
- logger.ts creates pino instance with dev/prod configuration
- prismaUtils.ts exports withSalonId utility function
- Both files compile without TypeScript errors
- Foundation ready for route migration plans
</success_criteria>

<output>
After completion, create `.planning/phases/17-code-quality/17-01-SUMMARY.md`
</output>
