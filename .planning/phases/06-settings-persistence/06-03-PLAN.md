---
phase: 06-settings-persistence
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/hooks/useLocations.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Selected location persists correctly after page refresh"
    - "Business hours shown match the location saved in localStorage"
    - "No race condition between localStorage read and API fetch"
  artifacts:
    - path: "apps/web/src/hooks/useLocations.tsx"
      provides: "Location context with correct initialization order"
      contains: "fetchLocations"
  key_links:
    - from: "apps/web/src/hooks/useLocations.tsx"
      to: "localStorage.selectedLocationId"
      via: "useEffect initialization"
      pattern: "localStorage\\.getItem"
---

<objective>
Fix location context race condition that causes settings to appear not to persist

Purpose: Close Gap 1 from 06-02 verification. The race condition causes `fetchLocations` to use a stale closure value for `selectedLocationId`, which triggers auto-selection of the primary location instead of using the localStorage value. Users experience this as "settings not persisting" because they edit hours for Location A, refresh, and see hours for Location B (the primary).

Output: Location context that correctly restores the selected location from localStorage before fetching locations, eliminating the race condition.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-settings-persistence/06-02-SUMMARY.md

Key context from gap analysis:

**Root Cause (from 06-02-SUMMARY.md):**
```typescript
// In useLocations.tsx, the useEffect at line 347-355:
useEffect(() => {
  if (typeof window !== 'undefined') {
    const savedId = localStorage.getItem('selectedLocationId');
    if (savedId) {
      setSelectedLocationId(savedId);  // Queues state update (async)
    }
  }
  fetchLocations();  // Called immediately with stale closure
}, [fetchLocations]);
```

The problem:
1. `setSelectedLocationId(savedId)` queues a state update (async)
2. `fetchLocations()` is called IMMEDIATELY in the same effect
3. The `fetchLocations` callback has `selectedLocationId` in its dependency array
4. But the callback was created with the CLOSURE VALUE at render time (null)
5. So `fetchLocations` runs with `selectedLocationId=null` in its closure
6. Lines 131-137 auto-select primary location when `!selectedLocationId`
7. This selects a DIFFERENT location than where hours were saved
8. User sees hours for auto-selected location, not their saved location

**Impact:** Settings appear not to persist (but actually saved to different location)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix location context initialization race condition</name>
  <files>apps/web/src/hooks/useLocations.tsx</files>
  <action>
Fix the race condition by initializing `selectedLocationId` from localStorage BEFORE the first render, using lazy state initialization.

**Step 1: Change initial state to lazy initialization (around line 114)**

Replace:
```typescript
const [selectedLocationId, setSelectedLocationId] = useState<string | null>(null);
```

With:
```typescript
const [selectedLocationId, setSelectedLocationId] = useState<string | null>(() => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('selectedLocationId');
  }
  return null;
});
```

This ensures `selectedLocationId` has the correct value on the FIRST render, so `fetchLocations` closure captures the right value.

**Step 2: Remove duplicate localStorage read from useEffect (around line 347-355)**

Change the useEffect from:
```typescript
useEffect(() => {
  if (typeof window !== 'undefined') {
    const savedId = localStorage.getItem('selectedLocationId');
    if (savedId) {
      setSelectedLocationId(savedId);
    }
  }
  fetchLocations();
}, [fetchLocations]);
```

To:
```typescript
useEffect(() => {
  fetchLocations();
}, [fetchLocations]);
```

The localStorage read is now handled by lazy state initialization, so we only need to fetch locations.

**Step 3: Update fetchLocations to not auto-select if localStorage has a value**

The auto-selection logic at lines 131-137 should also check localStorage to avoid overwriting:

```typescript
// Auto-select primary location if none selected AND no localStorage value
if (!selectedLocationId && locationsData.length > 0) {
  // Double-check localStorage to avoid race with first render
  const savedId = typeof window !== 'undefined' ? localStorage.getItem('selectedLocationId') : null;
  if (!savedId) {
    const primary = locationsData.find((l) => l.isPrimary);
    if (primary) {
      setSelectedLocationId(primary.id);
    }
  }
}
```

This is a belt-and-suspenders approach: lazy init handles the common case, and this check handles any edge cases.

AVOID:
- Do not add setTimeout or requestAnimationFrame workarounds
- Do not change the localStorage persistence logic in selectLocation
- Do not modify how locations are fetched from the API
  </action>
  <verify>
    - TypeScript compiles: `cd apps/web && npx tsc --noEmit 2>&1 | head -20`
    - Lazy init present: `grep -A 5 "useState<string | null>(() =>" apps/web/src/hooks/useLocations.tsx`
    - No duplicate localStorage read in useEffect: `grep -A 8 "Fetch locations on mount" apps/web/src/hooks/useLocations.tsx`
  </verify>
  <done>Location context initializes selectedLocationId from localStorage synchronously via lazy state init, eliminating race condition</done>
</task>

</tasks>

<verification>
After task completion:

1. TypeScript compiles:
   ```bash
   cd apps/web && npx tsc --noEmit
   ```

2. Verify lazy initialization is in place:
   ```bash
   grep -B 1 -A 5 "useState<string | null>" apps/web/src/hooks/useLocations.tsx
   ```
   Should show the lazy init function, not `useState<string | null>(null)`

3. Verify useEffect no longer reads localStorage:
   ```bash
   grep -A 10 "Fetch locations on mount" apps/web/src/hooks/useLocations.tsx
   ```
   Should show only `fetchLocations()` call, not localStorage access

**Manual verification (requires running app):**
1. Select a non-primary location
2. Go to Settings > Business Hours
3. Change hours and save
4. Refresh the page
5. Verify the same location is still selected (not switched to primary)
6. Verify hours match what was saved
</verification>

<success_criteria>
- [ ] selectedLocationId uses lazy state initialization from localStorage
- [ ] useEffect only calls fetchLocations, no localStorage read
- [ ] fetchLocations auto-selection respects localStorage value
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-settings-persistence/06-03-SUMMARY.md`
</output>
