---
phase: 22-time-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - apps/api/src/routes/staffPortal.ts
autonomous: true

must_haves:
  truths:
    - "TimeEntry model exists in database with unique partial index preventing double clock-in"
    - "Staff can POST to clock-in endpoint and receive time entry with captured timezone"
    - "Staff can POST to clock-out endpoint and receive updated time entry with duration"
    - "Staff can GET current clock status (clocked in or not)"
    - "Staff can GET history with date range filtering"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "TimeEntry model definition"
      contains: "model TimeEntry"
    - path: "apps/api/src/routes/staffPortal.ts"
      provides: "Time clock API endpoints"
      exports: ["router"]
  key_links:
    - from: "apps/api/src/routes/staffPortal.ts"
      to: "prisma.timeEntry"
      via: "database queries"
      pattern: "prisma\\.timeEntry\\.(create|update|findFirst|findMany)"
    - from: "apps/api/src/routes/staffPortal.ts"
      to: "prisma.staffLocation"
      via: "location verification"
      pattern: "prisma\\.staffLocation\\.findUnique"
---

<objective>
Create TimeEntry database model and time clock API endpoints for staff portal.

Purpose: Establishes the data layer and API contract for staff time tracking, enabling clock in/out operations with timezone-aware storage and concurrency protection.

Output:
- TimeEntry model in Prisma schema with unique partial index
- API endpoints: POST /clock-in, POST /clock-out/:id, GET /status, GET /history
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-time-tracking/22-RESEARCH.md

# Existing patterns
@apps/api/src/routes/staffPortal.ts
@packages/database/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TimeEntry model to Prisma schema</name>
  <files>packages/database/prisma/schema.prisma</files>
  <action>
Add TimeEntry model to schema.prisma with these fields:
- id: String @id @default(uuid())
- staffId: String @map("staff_id")
- salonId: String @map("salon_id")
- locationId: String @map("location_id")
- clockIn: DateTime @map("clock_in")
- clockOut: DateTime? @map("clock_out")
- timezone: String (captured from location at clock-in time)
- notes: String? (for manager adjustment reasons)
- createdAt: DateTime @default(now()) @map("created_at")
- updatedAt: DateTime @updatedAt @map("updated_at")

Add relations:
- location: Location @relation(fields: [locationId], references: [id])
- salon: Salon @relation(fields: [salonId], references: [id], onDelete: Cascade)
- staff: User @relation(fields: [staffId], references: [id], onDelete: Cascade)

Add indexes:
- @@index([staffId, clockIn])
- @@index([salonId, clockIn])
- @@index([locationId, clockIn])

Add unique partial index for double clock-in prevention:
- @@unique([staffId], map: "one_active_entry_per_staff", where: "clock_out IS NULL")
Note: Prisma doesn't support partial unique indexes directly. Instead use:
- @@unique([staffId, clockOut], name: "unique_active_entry")
This allows only one NULL clockOut per staffId (PostgreSQL treats each NULL as unique in unique constraints, but we'll handle the constraint check in application code + add a check constraint via raw SQL migration if needed).

Actually, the safer approach for Prisma is to use application-level check + database unique index via raw SQL. For now, add standard indexes and handle concurrency in application code by checking existing active entry before create.

Add to User model: timeEntries TimeEntry[]
Add to Salon model: timeEntries TimeEntry[]
Add to Location model: timeEntries TimeEntry[]

Map table name: @@map("time_entries")

Run: cd packages/database && pnpm prisma db push
  </action>
  <verify>
Run `cd C:/projects/spa-final/packages/database && pnpm prisma db push` succeeds without errors.
Run `pnpm prisma studio` and verify TimeEntry model appears.
  </verify>
  <done>TimeEntry model exists in schema with all fields, relations, and indexes. Database schema is updated.</done>
</task>

<task type="auto">
  <name>Task 2: Add time clock API endpoints to staffPortal.ts</name>
  <files>apps/api/src/routes/staffPortal.ts</files>
  <action>
Add the following endpoints to staffPortal.ts:

1. **GET /staff-portal/time-clock/status**
   - Uses authenticate, staffOnly middleware
   - Returns { isClockedIn: boolean, activeEntry: TimeEntry | null, canClockIn: boolean }
   - Finds active entry: prisma.timeEntry.findFirst({ where: { staffId, clockOut: null } })
   - Include location name in response

2. **POST /staff-portal/time-clock/clock-in**
   - Uses authenticate, staffOnly middleware
   - Body: { locationId: string }
   - Verify staff is assigned to location via StaffLocation
   - Check no existing active entry (clockOut: null)
   - If already clocked in, return 400 with ALREADY_CLOCKED_IN code
   - Get location timezone: location.timezone || salon.timezone || 'UTC'
   - Create TimeEntry with clockIn: new Date(), captured timezone
   - Return created entry

3. **POST /staff-portal/time-clock/clock-out/:entryId**
   - Uses authenticate, staffOnly middleware
   - Verify entry exists and belongs to this staff
   - If entry.clockOut already set, return 400 with ALREADY_CLOCKED_OUT
   - Update entry with clockOut: new Date()
   - Return updated entry with calculated durationMinutes

4. **GET /staff-portal/time-clock/history**
   - Uses authenticate, staffOnly middleware
   - Query params: startDate?, endDate? (default last 30 days)
   - Returns entries with: id, clockIn, clockOut, locationId, locationName, timezone, durationMinutes, isActive
   - Use date-fns differenceInMinutes for duration calculation
   - Order by clockIn desc
   - Include location name via relation

Add zod validation schemas:
- clockInSchema: z.object({ locationId: z.string().uuid() })
- historyQuerySchema with optional startDate, endDate strings

Import date-fns functions: differenceInMinutes, subDays, startOfDay, endOfDay

Follow existing asyncHandler pattern for all routes.
Follow existing withSalonId pattern for multi-tenant filtering.
  </action>
  <verify>
Start API server: `cd C:/projects/spa-final/apps/api && pnpm dev`

Test with curl (replace TOKEN with valid staff token):
```bash
# Get status
curl -X GET http://localhost:3001/api/v1/staff-portal/time-clock/status \
  -H "Authorization: Bearer TOKEN"

# Clock in (use valid locationId)
curl -X POST http://localhost:3001/api/v1/staff-portal/time-clock/clock-in \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"locationId": "LOCATION_ID"}'

# Clock out
curl -X POST http://localhost:3001/api/v1/staff-portal/time-clock/clock-out/ENTRY_ID \
  -H "Authorization: Bearer TOKEN"

# Get history
curl -X GET http://localhost:3001/api/v1/staff-portal/time-clock/history \
  -H "Authorization: Bearer TOKEN"
```

All endpoints should return 200 with expected data structure.
  </verify>
  <done>
Time clock API endpoints exist and work correctly:
- GET /status returns clock status
- POST /clock-in creates entry with location verification
- POST /clock-out/:id updates entry with clock-out time
- GET /history returns paginated history with duration calculations
  </done>
</task>

<task type="auto">
  <name>Task 3: Install date-fns-tz and add timezone formatting utility</name>
  <files>apps/api/package.json, apps/web/package.json</files>
  <action>
Install date-fns-tz in both apps for timezone-aware formatting:

```bash
cd C:/projects/spa-final
pnpm --filter api add date-fns-tz
pnpm --filter web add date-fns-tz
```

In the API routes (Task 2), use formatInTimeZone from date-fns-tz if needed for any server-side formatting.

The main timezone formatting will happen on the frontend (Plan 02), but having the package available in the API allows for future server-side formatting needs.

Note: date-fns 3.2.0 is already installed. date-fns-tz 3.x is compatible.
  </action>
  <verify>
Run `cd C:/projects/spa-final && pnpm install` completes.
Check packages are in node_modules: `ls node_modules/date-fns-tz`
  </verify>
  <done>date-fns-tz is installed in both api and web apps for timezone formatting.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Schema verification:**
   - TimeEntry model in schema.prisma with all fields
   - Relations to User, Salon, Location
   - Indexes on staffId, salonId, locationId

2. **API verification:**
   - All 4 endpoints respond correctly
   - Clock-in creates entry with timezone captured
   - Clock-out updates entry and calculates duration
   - Double clock-in returns 400 error
   - History returns entries sorted by date desc

3. **Package verification:**
   - date-fns-tz installed in api and web packages
</verification>

<success_criteria>
- [ ] TimeEntry model exists in Prisma schema with all required fields
- [ ] Database migration applied successfully (prisma db push)
- [ ] GET /status endpoint returns clock status
- [ ] POST /clock-in endpoint creates entry with location verification
- [ ] POST /clock-out/:id endpoint updates entry
- [ ] GET /history endpoint returns entries with duration
- [ ] Double clock-in returns 400 error
- [ ] date-fns-tz installed in both packages
</success_criteria>

<output>
After completion, create `.planning/phases/22-time-tracking/22-01-SUMMARY.md`
</output>
