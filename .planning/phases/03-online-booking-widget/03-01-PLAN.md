---
phase: 03-online-booking-widget
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/services/booking.ts
  - apps/api/src/routes/public.ts
autonomous: true

must_haves:
  truths:
    - "Client can successfully book an available time slot"
    - "Concurrent booking attempts for same slot result in exactly one success and others receive conflict error"
    - "Failed booking attempts due to transient database errors are automatically retried"
    - "Two clients booking the same slot simultaneously never results in double-booking"
  artifacts:
    - path: "apps/api/src/services/booking.ts"
      provides: "Booking service with transaction handling and pessimistic locking"
      exports: ["createBookingWithLock", "BookingConflictError"]
    - path: "apps/api/src/routes/public.ts"
      provides: "Refactored booking endpoint using booking service"
      contains: "createBookingWithLock"
  key_links:
    - from: "apps/api/src/routes/public.ts"
      to: "apps/api/src/services/booking.ts"
      via: "import and function call"
      pattern: "createBookingWithLock"
    - from: "apps/api/src/services/booking.ts"
      to: "@prisma/client"
      via: "Prisma interactive transaction with isolation level"
      pattern: "\\$transaction.*isolationLevel.*RepeatableRead"
---

<objective>
Implement transactional booking with pessimistic locking to prevent double-bookings.

Purpose: The current booking endpoint has a race condition window where conflict checks happen outside a transaction, allowing two concurrent requests to both see the slot as available and create overlapping appointments. This plan adds database-level protection with row locking.

Output: A booking service module with transaction handling, and the public booking endpoint refactored to use it.
</objective>

<execution_context>
@C:\Users\aaron\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\aaron\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-online-booking-widget/03-RESEARCH.md

# Key source files
@apps/api/src/routes/public.ts (lines 785-1134 - current booking endpoint)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create booking service with transaction handling</name>
  <files>apps/api/src/services/booking.ts</files>
  <action>
Create a new booking service module that implements:

1. Export `BookingConflictError` class extending Error with `code: 'TIME_CONFLICT'`

2. Export `createBookingWithLock` async function that:
   - Accepts booking data: `{ salonId, clientId, staffId, serviceId, locationId?, startTime, endTime, durationMinutes, price, notes?, source }`
   - Uses `prisma.$transaction()` with interactive mode and `{ isolationLevel: 'RepeatableRead', maxWait: 5000, timeout: 10000 }`
   - Inside transaction:
     a. Use `$queryRaw` with `SELECT id FROM "Appointment" WHERE "staffId" = ${staffId} AND status NOT IN ('cancelled') AND (overlap check) FOR UPDATE SKIP LOCKED`
     b. If any rows returned, throw `BookingConflictError`
     c. Create appointment with `tx.appointment.create()`
     d. Return created appointment
   - Wraps entire transaction in retry loop (5 attempts) for P2034 errors with exponential backoff

Overlap check SQL condition:
```sql
(
  ("startTime" <= ${startTime}::timestamp AND "endTime" > ${startTime}::timestamp)
  OR ("startTime" < ${endTime}::timestamp AND "endTime" >= ${endTime}::timestamp)
  OR ("startTime" >= ${startTime}::timestamp AND "endTime" <= ${endTime}::timestamp)
)
```

Include JSDoc comments explaining the locking strategy.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
pnpm --filter @peacase/api exec tsc --noEmit
```
  </verify>
  <done>
Booking service file exists with createBookingWithLock function that uses Prisma interactive transaction with RepeatableRead isolation and raw SQL row locking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor booking endpoint to use booking service</name>
  <files>apps/api/src/routes/public.ts</files>
  <action>
Refactor the `POST /:slug/book` endpoint (lines 785-1134) to use the new booking service:

1. Import at top of file:
   ```typescript
   import { createBookingWithLock, BookingConflictError } from '../services/booking';
   ```

2. Keep all existing validation and setup code (salon lookup, service lookup, staff assignment, client find/create) - these are correct.

3. Replace the manual conflict check and `prisma.appointment.create()` call with:
   ```typescript
   try {
     const appointment = await createBookingWithLock({
       salonId: salon.id,
       clientId: client.id,
       staffId: assignedStaffId,
       serviceId: serviceId,
       locationId: locationId || null,
       startTime: start,
       endTime: end,
       durationMinutes: effectiveDuration,
       price: effectivePrice,
       notes,
       source: 'online_booking',
     });
     // ... rest of response handling
   } catch (error) {
     if (error instanceof BookingConflictError) {
       return res.status(400).json({
         success: false,
         error: {
           code: 'TIME_CONFLICT',
           message: 'This time slot is no longer available',
         },
       });
     }
     throw error;
   }
   ```

4. Remove the duplicate conflict check code (the prisma.appointment.findFirst overlap check block) since the service now handles this atomically.

5. Keep the email/SMS sending and response formatting after successful booking.

IMPORTANT: Preserve all the staff assignment logic (lines 839-936) that handles "Any available" staff selection - this runs BEFORE the booking service call.
  </action>
  <verify>
1. TypeScript compiles: `pnpm --filter @peacase/api exec tsc --noEmit`
2. API starts: `pnpm --filter @peacase/api dev` (check for startup errors)
3. Existing tests pass: `pnpm --filter @peacase/api test`
  </verify>
  <done>
Booking endpoint uses createBookingWithLock for atomic booking creation, duplicate conflict check code removed, error handling catches BookingConflictError.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit test for booking service retry logic</name>
  <files>apps/api/src/__tests__/booking-service.test.ts</files>
  <action>
Create a unit test file for the booking service that tests:

1. **Successful booking creation** - Verify appointment is created with all fields
2. **Conflict detection** - Mock overlapping appointment, verify BookingConflictError thrown
3. **Retry on P2034** - Mock transaction to throw P2034 twice then succeed, verify 3 attempts made and booking succeeds
4. **Max retries exceeded** - Mock transaction to always throw P2034, verify error after 5 attempts

Use vitest and the existing test setup pattern from `apps/api/src/__tests__/setup.ts`.

Mock prisma.$transaction and prisma.$queryRaw as needed.
  </action>
  <verify>
```bash
pnpm --filter @peacase/api test booking-service
```
All tests pass.
  </verify>
  <done>
Unit tests exist for booking service covering success, conflict, retry, and max retry scenarios.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript clean:** `pnpm --filter @peacase/api exec tsc --noEmit` exits 0
2. **Tests pass:** `pnpm --filter @peacase/api test` all green
3. **Code review:**
   - Booking service uses RepeatableRead isolation level
   - Raw SQL includes `FOR UPDATE SKIP LOCKED`
   - Retry loop handles P2034 with exponential backoff
   - Booking endpoint catches BookingConflictError

</verification>

<success_criteria>
- Booking service module exists with createBookingWithLock function
- Function uses Prisma interactive transaction with RepeatableRead isolation
- Row-level locking implemented with SELECT FOR UPDATE SKIP LOCKED
- Retry logic handles P2034 errors (up to 5 attempts, exponential backoff)
- Booking endpoint refactored to use the service
- Unit tests cover retry behavior
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-online-booking-widget/03-01-SUMMARY.md`
</output>
