# Plan 09-05: Test Suite - Session Persistence & Tenant Isolation Tests

## Goal
Create automated tests to verify session persistence, token refresh, and two-salon tenant isolation. These tests prevent regression and validate the security fixes from plans 09-01 through 09-04.

## Tasks

### Task 1: Create Tenant Isolation Test Utilities
**File:** `apps/api/src/__tests__/utils/tenant-isolation.ts`

```typescript
import { prisma } from '../../lib/prisma';
import jwt from 'jsonwebtoken';

export interface TestSalon {
  id: string;
  slug: string;
  token: string;
  userId: string;
}

export async function createTestSalon(suffix: string): Promise<TestSalon> {
  const salon = await prisma.salon.create({
    data: {
      name: `Test Salon ${suffix}`,
      slug: `test-salon-${suffix}-${Date.now()}`,
      email: `test-${suffix}@example.com`,
      phone: '555-0100',
    }
  });

  const user = await prisma.user.create({
    data: {
      email: `owner-${suffix}@example.com`,
      password: 'hashed_password',
      firstName: 'Test',
      lastName: `Owner ${suffix}`,
      role: 'owner',
      salonId: salon.id,
    }
  });

  const token = jwt.sign(
    { userId: user.id, salonId: salon.id, role: 'owner' },
    process.env.JWT_SECRET!,
    { expiresIn: '1h' }
  );

  return { id: salon.id, slug: salon.slug, token, userId: user.id };
}

export async function cleanupTestSalon(salonId: string): Promise<void> {
  // Delete in correct order to respect foreign keys
  await prisma.appointment.deleteMany({ where: { salonId } });
  await prisma.client.deleteMany({ where: { salonId } });
  await prisma.service.deleteMany({ where: { salonId } });
  await prisma.user.deleteMany({ where: { salonId } });
  await prisma.location.deleteMany({ where: { salonId } });
  await prisma.salon.delete({ where: { id: salonId } });
}

export async function createTestClient(salonId: string): Promise<string> {
  const client = await prisma.client.create({
    data: {
      firstName: 'Test',
      lastName: 'Client',
      email: `client-${Date.now()}@example.com`,
      salonId,
    }
  });
  return client.id;
}

export async function createTestAppointment(
  salonId: string,
  clientId: string,
  staffId: string
): Promise<string> {
  const appointment = await prisma.appointment.create({
    data: {
      salonId,
      clientId,
      staffId,
      startTime: new Date(),
      endTime: new Date(Date.now() + 3600000),
      status: 'scheduled',
    }
  });
  return appointment.id;
}
```

---

### Task 2: Create Two-Salon Isolation Tests
**File:** `apps/api/src/__tests__/tenant-isolation.test.ts`

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import { app } from '../app';
import {
  createTestSalon,
  cleanupTestSalon,
  createTestClient,
  createTestAppointment,
  TestSalon
} from './utils/tenant-isolation';

describe('Tenant Isolation', () => {
  let salonA: TestSalon;
  let salonB: TestSalon;
  let clientA: string;
  let clientB: string;
  let appointmentA: string;
  let appointmentB: string;

  beforeAll(async () => {
    salonA = await createTestSalon('A');
    salonB = await createTestSalon('B');

    clientA = await createTestClient(salonA.id);
    clientB = await createTestClient(salonB.id);

    appointmentA = await createTestAppointment(salonA.id, clientA, salonA.userId);
    appointmentB = await createTestAppointment(salonB.id, clientB, salonB.userId);
  });

  afterAll(async () => {
    await cleanupTestSalon(salonA.id);
    await cleanupTestSalon(salonB.id);
  });

  describe('Appointments', () => {
    it('salon A cannot read salon B appointments', async () => {
      const response = await request(app)
        .get(`/api/v1/appointments/${appointmentB}`)
        .set('Authorization', `Bearer ${salonA.token}`);

      expect(response.status).toBe(404);
    });

    it('salon A cannot update salon B appointments', async () => {
      const response = await request(app)
        .patch(`/api/v1/appointments/${appointmentB}`)
        .set('Authorization', `Bearer ${salonA.token}`)
        .send({ notes: 'hacked' });

      expect(response.status).toBe(404);
    });

    it('salon A cannot delete salon B appointments', async () => {
      const response = await request(app)
        .post(`/api/v1/appointments/${appointmentB}/cancel`)
        .set('Authorization', `Bearer ${salonA.token}`);

      expect(response.status).toBe(404);
    });

    it('salon A list does not include salon B appointments', async () => {
      const response = await request(app)
        .get('/api/v1/appointments')
        .set('Authorization', `Bearer ${salonA.token}`);

      expect(response.status).toBe(200);
      const ids = response.body.data.map((a: any) => a.id);
      expect(ids).not.toContain(appointmentB);
    });
  });

  describe('Clients', () => {
    it('salon A cannot read salon B clients', async () => {
      const response = await request(app)
        .get(`/api/v1/clients/${clientB}`)
        .set('Authorization', `Bearer ${salonA.token}`);

      expect(response.status).toBe(404);
    });

    it('salon A cannot update salon B clients', async () => {
      const response = await request(app)
        .patch(`/api/v1/clients/${clientB}`)
        .set('Authorization', `Bearer ${salonA.token}`)
        .send({ firstName: 'Hacked' });

      expect(response.status).toBe(404);
    });

    it('salon A list does not include salon B clients', async () => {
      const response = await request(app)
        .get('/api/v1/clients')
        .set('Authorization', `Bearer ${salonA.token}`);

      expect(response.status).toBe(200);
      const ids = response.body.data.map((c: any) => c.id);
      expect(ids).not.toContain(clientB);
    });
  });

  describe('Services', () => {
    let serviceB: string;

    beforeAll(async () => {
      const service = await prisma.service.create({
        data: {
          name: 'Test Service B',
          duration: 60,
          price: 100,
          salonId: salonB.id,
        }
      });
      serviceB = service.id;
    });

    it('salon A cannot read salon B services', async () => {
      const response = await request(app)
        .get(`/api/v1/services/${serviceB}`)
        .set('Authorization', `Bearer ${salonA.token}`);

      expect(response.status).toBe(404);
    });

    it('salon A cannot update salon B services', async () => {
      const response = await request(app)
        .patch(`/api/v1/services/${serviceB}`)
        .set('Authorization', `Bearer ${salonA.token}`)
        .send({ price: 0 });

      expect(response.status).toBe(404);
    });
  });

  describe('Staff', () => {
    it('salon A cannot read salon B staff', async () => {
      const response = await request(app)
        .get(`/api/v1/staff/${salonB.userId}`)
        .set('Authorization', `Bearer ${salonA.token}`);

      expect(response.status).toBe(404);
    });

    it('salon A cannot update salon B staff', async () => {
      const response = await request(app)
        .patch(`/api/v1/staff/${salonB.userId}`)
        .set('Authorization', `Bearer ${salonA.token}`)
        .send({ firstName: 'Hacked' });

      expect(response.status).toBe(404);
    });
  });

  describe('Dashboard', () => {
    it('salon A dashboard does not include salon B data', async () => {
      const response = await request(app)
        .get('/api/v1/dashboard/stats')
        .set('Authorization', `Bearer ${salonA.token}`);

      expect(response.status).toBe(200);
      // Verify counts don't include salon B data
      // (specific assertions depend on dashboard response structure)
    });
  });
});
```

---

### Task 3: Create Session Persistence E2E Tests
**File:** `apps/web/e2e/session-persistence.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test.describe('Session Persistence', () => {
  const testUser = {
    email: 'e2e-test@example.com',
    password: 'TestPassword123!',
  };

  test('user stays logged in after page refresh', async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[name="email"]', testUser.email);
    await page.fill('[name="password"]', testUser.password);
    await page.click('button[type="submit"]');

    // Wait for dashboard
    await expect(page.locator('[data-testid="dashboard"]')).toBeVisible();

    // Refresh page
    await page.reload();

    // Should still be on dashboard, not redirected to login
    await expect(page.locator('[data-testid="dashboard"]')).toBeVisible();
    await expect(page).not.toHaveURL(/\/login/);
  });

  test('user stays logged in after closing and reopening tab', async ({ page, context }) => {
    // Login
    await page.goto('/login');
    await page.fill('[name="email"]', testUser.email);
    await page.fill('[name="password"]', testUser.password);
    await page.click('button[type="submit"]');
    await expect(page.locator('[data-testid="dashboard"]')).toBeVisible();

    // Close tab
    await page.close();

    // Open new tab in same context (shares localStorage)
    const newPage = await context.newPage();
    await newPage.goto('/dashboard');

    // Should be logged in
    await expect(newPage.locator('[data-testid="dashboard"]')).toBeVisible();
  });

  test('logout clears session and redirects to login', async ({ page }) => {
    // Login first
    await page.goto('/login');
    await page.fill('[name="email"]', testUser.email);
    await page.fill('[name="password"]', testUser.password);
    await page.click('button[type="submit"]');
    await expect(page.locator('[data-testid="dashboard"]')).toBeVisible();

    // Logout
    await page.click('[data-testid="logout-button"]');

    // Should be on login page
    await expect(page).toHaveURL(/\/login/);

    // Trying to access dashboard should redirect to login
    await page.goto('/dashboard');
    await expect(page).toHaveURL(/\/login/);
  });
});
```

---

### Task 4: Create Token Refresh Tests
**File:** `apps/api/src/__tests__/token-refresh.test.ts`

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import jwt from 'jsonwebtoken';
import { app } from '../app';
import { createTestSalon, cleanupTestSalon, TestSalon } from './utils/tenant-isolation';

describe('Token Refresh', () => {
  let salon: TestSalon;
  let refreshToken: string;

  beforeAll(async () => {
    salon = await createTestSalon('refresh-test');

    // Login to get refresh token
    const loginResponse = await request(app)
      .post('/api/v1/auth/login')
      .send({
        email: `owner-refresh-test@example.com`,
        password: 'test_password',
      });

    refreshToken = loginResponse.body.refreshToken;
  });

  afterAll(async () => {
    await cleanupTestSalon(salon.id);
  });

  it('refreshes token successfully with valid refresh token', async () => {
    const response = await request(app)
      .post('/api/v1/auth/refresh')
      .send({ refreshToken });

    expect(response.status).toBe(200);
    expect(response.body.accessToken).toBeDefined();
    expect(response.body.refreshToken).toBeDefined();

    // New tokens should be different (rotation)
    expect(response.body.refreshToken).not.toBe(refreshToken);
  });

  it('rejects expired refresh token', async () => {
    const expiredToken = jwt.sign(
      { userId: salon.userId, salonId: salon.id, role: 'owner', type: 'refresh' },
      process.env.JWT_REFRESH_SECRET!,
      { expiresIn: '-1h' } // Already expired
    );

    const response = await request(app)
      .post('/api/v1/auth/refresh')
      .send({ refreshToken: expiredToken });

    expect(response.status).toBe(401);
  });

  it('rejects invalid refresh token', async () => {
    const response = await request(app)
      .post('/api/v1/auth/refresh')
      .send({ refreshToken: 'invalid-token' });

    expect(response.status).toBe(401);
  });

  it('rejects refresh token after logout', async () => {
    // Get fresh tokens
    const loginResponse = await request(app)
      .post('/api/v1/auth/login')
      .send({
        email: `owner-refresh-test@example.com`,
        password: 'test_password',
      });

    const { accessToken, refreshToken: newRefreshToken } = loginResponse.body;

    // Logout
    await request(app)
      .post('/api/v1/auth/logout')
      .set('Authorization', `Bearer ${accessToken}`);

    // Try to use revoked refresh token
    const response = await request(app)
      .post('/api/v1/auth/refresh')
      .send({ refreshToken: newRefreshToken });

    expect(response.status).toBe(401);
  });

  it('maintains salonId consistency through refresh', async () => {
    const loginResponse = await request(app)
      .post('/api/v1/auth/login')
      .send({
        email: `owner-refresh-test@example.com`,
        password: 'test_password',
      });

    const refreshResponse = await request(app)
      .post('/api/v1/auth/refresh')
      .send({ refreshToken: loginResponse.body.refreshToken });

    // Decode new access token
    const decoded = jwt.decode(refreshResponse.body.accessToken) as any;

    // SalonId should be same as original
    expect(decoded.salonId).toBe(salon.id);
  });
});
```

---

### Task 5: Create Token Refresh E2E Tests
**File:** `apps/web/e2e/token-refresh.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test.describe('Token Refresh', () => {
  test('automatically refreshes token before expiry', async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[name="email"]', 'e2e-test@example.com');
    await page.fill('[name="password"]', 'TestPassword123!');
    await page.click('button[type="submit"]');
    await expect(page.locator('[data-testid="dashboard"]')).toBeVisible();

    // Get initial token
    const initialToken = await page.evaluate(() =>
      localStorage.getItem('peacase_access_token')
    );

    // Wait for refresh timer (mock shorter interval for test)
    // In real test, would need to manipulate time or use shorter intervals
    await page.waitForTimeout(35000); // Wait past 30-second check interval

    // Trigger an API call to ensure token check runs
    await page.click('[data-testid="refresh-dashboard"]');

    // Token should still be valid (either same or refreshed)
    const currentToken = await page.evaluate(() =>
      localStorage.getItem('peacase_access_token')
    );

    expect(currentToken).toBeDefined();
    // Dashboard should still be accessible
    await expect(page.locator('[data-testid="dashboard"]')).toBeVisible();
  });

  test('handles 401 by refreshing and retrying', async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[name="email"]', 'e2e-test@example.com');
    await page.fill('[name="password"]', 'TestPassword123!');
    await page.click('button[type="submit"]');
    await expect(page.locator('[data-testid="dashboard"]')).toBeVisible();

    // Corrupt the access token to force 401
    await page.evaluate(() => {
      localStorage.setItem('peacase_access_token', 'invalid-token');
    });

    // Make an API call - should get 401, refresh, and retry
    await page.click('[data-testid="load-clients"]');

    // Should still work (refresh happened automatically)
    await expect(page.locator('[data-testid="clients-list"]')).toBeVisible();
  });
});
```

---

### Task 6: Add Test Scripts to package.json
**File:** `apps/api/package.json`

```json
{
  "scripts": {
    "test": "vitest",
    "test:isolation": "vitest run src/__tests__/tenant-isolation.test.ts",
    "test:auth": "vitest run src/__tests__/token-refresh.test.ts",
    "test:security": "vitest run src/__tests__/tenant-isolation.test.ts src/__tests__/token-refresh.test.ts"
  }
}
```

**File:** `apps/web/package.json`

```json
{
  "scripts": {
    "test:e2e": "playwright test",
    "test:e2e:session": "playwright test e2e/session-persistence.spec.ts",
    "test:e2e:refresh": "playwright test e2e/token-refresh.spec.ts"
  }
}
```

---

### Task 7: Create CI Integration
**File:** `.github/workflows/security-tests.yml`

```yaml
name: Security Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  tenant-isolation:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: peacase_test
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/peacase_test
      - run: npm run test:security
        working-directory: apps/api
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/peacase_test
          JWT_SECRET: test-secret
          JWT_REFRESH_SECRET: test-refresh-secret

  e2e-auth:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npx playwright install --with-deps
      - run: npm run test:e2e:session
        working-directory: apps/web
      - run: npm run test:e2e:refresh
        working-directory: apps/web
```

---

## Success Criteria

1. Two-salon isolation tests pass: 0 cross-tenant access
2. Session persistence E2E tests pass: login survives refresh
3. Token refresh tests pass: automatic refresh works
4. All tests run in CI pipeline
5. Tests block deployment on failure
6. Test coverage includes: appointments, clients, services, staff, dashboard

## Files Created

- `apps/api/src/__tests__/utils/tenant-isolation.ts`
- `apps/api/src/__tests__/tenant-isolation.test.ts`
- `apps/api/src/__tests__/token-refresh.test.ts`
- `apps/web/e2e/session-persistence.spec.ts`
- `apps/web/e2e/token-refresh.spec.ts`
- `.github/workflows/security-tests.yml`

## Files Modified

- `apps/api/package.json` (test scripts)
- `apps/web/package.json` (test scripts)

---

*Plan created: 2026-01-28*
