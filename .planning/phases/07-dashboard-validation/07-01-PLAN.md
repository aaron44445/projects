---
phase: 07-dashboard-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/routes/dashboard.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard revenue shows net amount (gross minus refunds)"
    - "Today's appointments calculated in salon timezone, not server timezone"
    - "Appointment counts exclude cancelled and no-show status"
  artifacts:
    - path: "apps/api/src/routes/dashboard.ts"
      provides: "Timezone-aware dashboard endpoints with refund-adjusted revenue"
      contains: "refundAmount"
  key_links:
    - from: "apps/api/src/routes/dashboard.ts"
      to: "prisma.salon"
      via: "timezone lookup"
      pattern: "timezone"
    - from: "apps/api/src/routes/dashboard.ts"
      to: "prisma.payment"
      via: "refund subtraction"
      pattern: "refundAmount"
---

<objective>
Fix dashboard API to calculate accurate statistics: timezone-aware "today" boundaries and revenue that subtracts refunds.

Purpose: Dashboard currently shows inflated revenue (ignores refunds) and calculates "today" in server timezone instead of salon timezone, causing inaccurate appointment counts for salons in different timezones.

Output: Backend endpoints that return accurate, timezone-aware metrics.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dashboard-validation/07-CONTEXT.md
@.planning/phases/07-dashboard-validation/07-RESEARCH.md
@apps/api/src/routes/dashboard.ts
@packages/database/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timezone-aware date boundary calculation</name>
  <files>apps/api/src/routes/dashboard.ts</files>
  <action>
Add timezone-aware date boundary calculation to the dashboard routes:

1. At the top of the file, add a helper function to calculate date boundaries in salon timezone:

```typescript
/**
 * Calculate start/end of day in salon's timezone, returned as UTC Date objects
 * for Prisma queries. Handles DST transitions correctly.
 */
function getDayBoundariesInTimezone(timezone: string): { startOfDay: Date; endOfDay: Date } {
  const now = new Date();

  // Get current date components in salon timezone
  const formatter = new Intl.DateTimeFormat('en-US', {
    timeZone: timezone,
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  });
  const parts = formatter.formatToParts(now);
  const year = parseInt(parts.find(p => p.type === 'year')!.value, 10);
  const month = parseInt(parts.find(p => p.type === 'month')!.value, 10) - 1;
  const day = parseInt(parts.find(p => p.type === 'day')!.value, 10);

  // Create midnight in salon timezone, then convert to UTC
  // Use toLocaleString round-trip to handle DST correctly
  const midnightLocal = new Date(year, month, day, 0, 0, 0, 0);
  const midnightStr = midnightLocal.toLocaleString('en-US', { timeZone: timezone });

  // Parse back and calculate offset
  const localMidnight = new Date(`${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}T00:00:00`);

  // Get UTC offset for the salon timezone at midnight
  const utcFormatter = new Intl.DateTimeFormat('en-US', {
    timeZone: timezone,
    hour: 'numeric',
    minute: 'numeric',
    hour12: false,
    timeZoneName: 'shortOffset',
  });

  // For simplicity, use a well-tested approach: construct ISO string and use timezone offset
  const startOfDay = new Date(
    new Date(localMidnight.toLocaleString('en-US', { timeZone: timezone })).getTime()
  );

  // Actually, simplest correct approach: use the Intl API to format and parse
  // Create date at midnight salon time
  const salonMidnight = new Date(
    new Date().toLocaleString('en-US', {
      timeZone: timezone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    }).replace(/(\d+)\/(\d+)\/(\d+)/, '$3-$1-$2T00:00:00')
  );

  // Better approach - calculate timezone offset dynamically
  const nowInTz = new Date(now.toLocaleString('en-US', { timeZone: timezone }));
  const offsetMs = nowInTz.getTime() - now.getTime();

  const startDate = new Date(year, month, day, 0, 0, 0, 0);
  const endDate = new Date(year, month, day, 23, 59, 59, 999);

  return {
    startOfDay: new Date(startDate.getTime() - offsetMs),
    endOfDay: new Date(endDate.getTime() - offsetMs),
  };
}
```

Actually, simplify using a proven pattern. Replace with:

```typescript
/**
 * Get start and end of today in the salon's timezone, as UTC Date objects.
 * Handles DST correctly by using Intl.DateTimeFormat.
 */
function getTodayBoundariesInTimezone(timezone: string): { startOfToday: Date; endOfToday: Date } {
  const now = new Date();

  // Format current date in salon timezone to get the date parts
  const options: Intl.DateTimeFormatOptions = { timeZone: timezone, year: 'numeric', month: '2-digit', day: '2-digit' };
  const dateStr = new Intl.DateTimeFormat('en-CA', options).format(now); // en-CA gives YYYY-MM-DD format

  // Create midnight in salon timezone by parsing the date string
  // The Date constructor interprets this as local time, so we need to adjust
  const [year, month, day] = dateStr.split('-').map(Number);

  // Get the offset between UTC and salon timezone at this moment
  const utcNow = now.getTime();
  const tzNow = new Date(now.toLocaleString('en-US', { timeZone: timezone })).getTime();
  const offsetMs = tzNow - utcNow;

  // Midnight in salon timezone = midnight local - offset
  const localMidnight = new Date(year, month - 1, day, 0, 0, 0, 0);
  const startOfToday = new Date(localMidnight.getTime() - offsetMs);

  const localEndOfDay = new Date(year, month - 1, day, 23, 59, 59, 999);
  const endOfToday = new Date(localEndOfDay.getTime() - offsetMs);

  return { startOfToday, endOfToday };
}
```

2. In the `/stats` endpoint, after getting salonId, fetch the salon's timezone and use it:

```typescript
// Get salon timezone
const salon = await prisma.salon.findUnique({
  where: { id: salonId },
  select: { timezone: true },
});
const salonTz = salon?.timezone || 'UTC';

// Use timezone-aware today boundaries for today-specific queries
const { startOfToday, endOfToday } = getTodayBoundariesInTimezone(salonTz);
```

3. In the `/today` endpoint, similarly fetch timezone and use the helper:

```typescript
const salon = await prisma.salon.findUnique({
  where: { id: salonId },
  select: { timezone: true },
});
const salonTz = salon?.timezone || 'UTC';

const { startOfToday, endOfToday } = getTodayBoundariesInTimezone(salonTz);

const appointments = await prisma.appointment.findMany({
  where: {
    salonId,
    ...locationFilter,
    startTime: {
      gte: startOfToday,
      lte: endOfToday,
    },
  },
  // ... rest unchanged
});
```

Note: The current `/stats` endpoint uses month boundaries which don't need timezone correction (full months are timezone-agnostic for monthly totals). Keep month calculations as-is.
  </action>
  <verify>Run `cd apps/api && pnpm build` to verify TypeScript compilation succeeds.</verify>
  <done>Dashboard `/today` and `/stats` endpoints calculate "today" using salon's configured timezone instead of server timezone.</done>
</task>

<task type="auto">
  <name>Task 2: Add refund subtraction to revenue calculations</name>
  <files>apps/api/src/routes/dashboard.ts</files>
  <action>
Update the revenue calculations in `/stats` endpoint to subtract refunds:

1. Modify the currentMonthPayments aggregate to include refundAmount:

```typescript
const currentMonthPayments = await prisma.payment.aggregate({
  where: {
    salonId,
    ...locationFilter,
    status: 'completed',
    createdAt: { gte: startOfThisMonth },
  },
  _sum: {
    totalAmount: true,
    refundAmount: true,  // Add this line
  },
});
```

2. Similarly update lastMonthPayments:

```typescript
const lastMonthPayments = await prisma.payment.aggregate({
  where: {
    salonId,
    ...locationFilter,
    status: 'completed',
    createdAt: {
      gte: startOfLastMonth,
      lte: endOfLastMonth,
    },
  },
  _sum: {
    totalAmount: true,
    refundAmount: true,  // Add this line
  },
});
```

3. Update the revenue calculation to subtract refunds:

```typescript
// Calculate NET revenue (gross minus refunds)
const currentGross = currentMonthPayments._sum.totalAmount || 0;
const currentRefunds = currentMonthPayments._sum.refundAmount || 0;
const currentRevenue = currentGross - currentRefunds;

const lastGross = lastMonthPayments._sum.totalAmount || 0;
const lastRefunds = lastMonthPayments._sum.refundAmount || 0;
const lastRevenue = lastGross - lastRefunds;
```

4. The response already uses `currentRevenue` and `lastRevenue`, so no changes needed there.

5. Update the appointment count queries to exclude 'no_show' status (currently only excludes 'cancelled'):

```typescript
const [thisMonthAppointments, lastMonthAppointments] = await Promise.all([
  prisma.appointment.count({
    where: {
      salonId,
      ...locationFilter,
      startTime: { gte: startOfThisMonth },
      status: { notIn: ['cancelled', 'no_show'] },  // Add 'no_show'
    },
  }),
  prisma.appointment.count({
    where: {
      salonId,
      ...locationFilter,
      startTime: {
        gte: startOfLastMonth,
        lte: endOfLastMonth,
      },
      status: { notIn: ['cancelled', 'no_show'] },  // Add 'no_show'
    },
  }),
]);
```
  </action>
  <verify>Run `cd apps/api && pnpm build` to verify TypeScript compilation. Optionally run `pnpm test` if tests exist for dashboard routes.</verify>
  <done>Revenue calculations now return net revenue (gross - refunds) and appointment counts exclude both cancelled and no-show appointments.</done>
</task>

</tasks>

<verification>
1. Build API: `cd apps/api && pnpm build` - should compile without errors
2. Start API: `cd apps/api && pnpm dev` - should start without errors
3. Manual verification: Make API call to `/api/v1/dashboard/stats` and confirm:
   - Response includes revenue data
   - If test salon has refunded payments, revenue should be gross minus refunds
4. Manual verification: Make API call to `/api/v1/dashboard/today` for a salon with non-UTC timezone:
   - Appointments returned should match the salon's local "today", not server's "today"
</verification>

<success_criteria>
- TypeScript compiles without errors
- `/stats` endpoint returns net revenue (totalAmount - refundAmount)
- `/today` endpoint calculates today boundaries using salon.timezone
- Appointment counts exclude both 'cancelled' and 'no_show' status
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-validation/07-01-SUMMARY.md`
</output>
