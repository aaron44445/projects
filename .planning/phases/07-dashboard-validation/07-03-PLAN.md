---
phase: 07-dashboard-validation
plan: 03
type: execute
wave: 2
depends_on: ["07-02"]
files_modified:
  - apps/web/src/app/dashboard/page.tsx
  - apps/web/src/hooks/useDashboard.ts
autonomous: true

must_haves:
  truths:
    - "Failed stats section shows error message while appointments section works"
    - "Failed appointments section shows error message while stats section works"
    - "Each failed section has its own retry button"
    - "Network errors show user-friendly messages, not technical errors"
  artifacts:
    - path: "apps/web/src/app/dashboard/page.tsx"
      provides: "Partial error state handling per section"
      contains: "ErrorCard"
  key_links:
    - from: "apps/web/src/app/dashboard/page.tsx"
      to: "apps/web/src/hooks/useDashboard.ts"
      via: "separate query hooks"
      pattern: "useDashboardStats.*useDashboardToday"
---

<objective>
Implement graceful degradation with partial error states so one API failure doesn't break the entire dashboard.

Purpose: Currently if any dashboard API call fails, the entire dashboard shows an error. Owners should still see stats if only the appointments section fails, and vice versa.

Output: Dashboard with independent error handling per section (stats, appointments, activity).
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dashboard-validation/07-CONTEXT.md
@.planning/phases/07-dashboard-validation/07-RESEARCH.md
@.planning/phases/07-dashboard-validation/07-02-SUMMARY.md
@apps/web/src/hooks/useDashboard.ts
@apps/web/src/app/dashboard/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Split useDashboard into independent queries</name>
  <files>apps/web/src/hooks/useDashboard.ts</files>
  <action>
Refactor useDashboard to use three independent queries instead of one combined query. This allows partial failures:

```typescript
'use client';

import { useQuery, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';

// Interface definitions (keep existing)
interface DashboardStats {
  todayAppointments: number;
  todayRevenue: number;
  monthRevenue: number;
  revenueChange: string;
  newClients: number;
  clientsChange: number;
}

interface ApiStatsResponse {
  revenue: { current: number; previous: number; change: number };
  appointments: { current: number; previous: number; change: number };
  newClients: { current: number; previous: number; change: number };
  totalClients: number;
  rating: { average: number | null; count: number };
}

interface TodayAppointment {
  id: string;
  startTime: string;
  endTime: string;
  status: string;
  client: { firstName: string; lastName: string };
  staff: { firstName: string; lastName: string };
  service: { name: string; color: string };
}

export interface RecentActivityItem {
  id: string;
  action: string;
  detail: string;
  time: string;
  type: 'booking' | 'payment' | 'client' | 'review' | 'cancellation';
}

interface RecentAppointment {
  id: string;
  status: string;
  createdAt: string;
  price: number;
  client: { firstName: string; lastName: string };
  service: { name: string };
}

// Helper functions (keep existing)
function formatRelativeTime(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins} min ago`;
  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
  if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
  return date.toLocaleDateString();
}

function transformToActivity(appointments: RecentAppointment[]): RecentActivityItem[] {
  return appointments.map((apt) => {
    const clientName = `${apt.client.firstName} ${apt.client.lastName}`;

    if (apt.status === 'cancelled') {
      return {
        id: apt.id,
        action: 'Booking cancelled',
        detail: `${clientName} cancelled ${apt.service.name}`,
        time: formatRelativeTime(apt.createdAt),
        type: 'cancellation' as const,
      };
    }

    if (apt.status === 'completed') {
      return {
        id: apt.id,
        action: 'Payment received',
        detail: `$${apt.price} from ${clientName}`,
        time: formatRelativeTime(apt.createdAt),
        type: 'payment' as const,
      };
    }

    return {
      id: apt.id,
      action: 'New booking',
      detail: `${clientName} booked ${apt.service.name}`,
      time: formatRelativeTime(apt.createdAt),
      type: 'booking' as const,
    };
  });
}

// Shared query options for auto-refresh
const sharedQueryOptions = {
  refetchInterval: 60000,
  refetchIntervalInBackground: true,
  refetchOnWindowFocus: true,
  staleTime: 30000,
  gcTime: 300000,
  retry: 3,
  retryDelay: (attemptIndex: number) => Math.min(1000 * 2 ** attemptIndex, 30000),
};

// Individual fetch functions
async function fetchStats(locationId?: string | null) {
  const locationParam = locationId ? `?locationId=${locationId}` : '';
  const response = await api.get<ApiStatsResponse>(`/dashboard/stats${locationParam}`);
  const apiData = response.data;

  return {
    todayAppointments: 0, // Will be filled from appointments query
    todayRevenue: 0,
    monthRevenue: apiData?.revenue?.current ?? 0,
    revenueChange: `${apiData?.revenue?.change ?? 0}%`,
    newClients: apiData?.newClients?.current ?? 0,
    clientsChange: apiData?.newClients?.change ?? 0,
  };
}

async function fetchTodayAppointments(locationId?: string | null) {
  const locationParam = locationId ? `?locationId=${locationId}` : '';
  const response = await api.get<{ appointments: TodayAppointment[]; summary: { total: number } } | TodayAppointment[]>(
    `/dashboard/today${locationParam}`
  );
  const todayData = response.data;

  return Array.isArray(todayData)
    ? todayData
    : (todayData?.appointments ?? []);
}

async function fetchRecentActivity(locationId?: string | null) {
  const locationParam = locationId ? `?locationId=${locationId}` : '';
  const response = await api.get<RecentAppointment[]>(`/dashboard/recent-activity${locationParam}`);
  const recentData = Array.isArray(response.data) ? response.data : [];
  return transformToActivity(recentData);
}

/**
 * Main dashboard hook with independent queries for graceful degradation
 */
export function useDashboard(locationId?: string | null) {
  const queryClient = useQueryClient();

  // Stats query (revenue, new clients)
  const statsQuery = useQuery({
    queryKey: ['dashboard', 'stats', locationId],
    queryFn: () => fetchStats(locationId),
    ...sharedQueryOptions,
  });

  // Today's appointments query
  const appointmentsQuery = useQuery({
    queryKey: ['dashboard', 'appointments', locationId],
    queryFn: () => fetchTodayAppointments(locationId),
    ...sharedQueryOptions,
  });

  // Recent activity query
  const activityQuery = useQuery({
    queryKey: ['dashboard', 'activity', locationId],
    queryFn: () => fetchRecentActivity(locationId),
    ...sharedQueryOptions,
  });

  // Combine stats with appointment count
  const stats: DashboardStats | null = statsQuery.data
    ? {
        ...statsQuery.data,
        todayAppointments: appointmentsQuery.data?.length ?? 0,
      }
    : null;

  // Refetch all queries
  const refetch = () => {
    statsQuery.refetch();
    appointmentsQuery.refetch();
    activityQuery.refetch();
  };

  // Format error messages to be user-friendly
  const formatError = (error: unknown): string | null => {
    if (!error) return null;
    if (error instanceof Error) {
      // Common error patterns -> user-friendly messages
      if (error.message.includes('fetch') || error.message.includes('network')) {
        return 'Unable to connect. Check your internet connection.';
      }
      if (error.message.includes('401') || error.message.includes('403')) {
        return 'Session expired. Please refresh the page.';
      }
      if (error.message.includes('500') || error.message.includes('server')) {
        return 'Server error. Please try again later.';
      }
      return error.message;
    }
    return 'An unexpected error occurred.';
  };

  return {
    // Stats data and state
    stats,
    statsLoading: statsQuery.isLoading,
    statsError: formatError(statsQuery.error),
    refetchStats: () => statsQuery.refetch(),

    // Appointments data and state
    todayAppointments: appointmentsQuery.data ?? [],
    appointmentsLoading: appointmentsQuery.isLoading,
    appointmentsError: formatError(appointmentsQuery.error),
    refetchAppointments: () => appointmentsQuery.refetch(),

    // Activity data and state
    recentActivity: activityQuery.data ?? [],
    activityLoading: activityQuery.isLoading,
    activityError: formatError(activityQuery.error),
    refetchActivity: () => activityQuery.refetch(),

    // Legacy compatibility (overall loading/error state)
    loading: statsQuery.isLoading || appointmentsQuery.isLoading,
    error: statsQuery.error || appointmentsQuery.error
      ? formatError(statsQuery.error || appointmentsQuery.error)
      : null,
    refetch,
  };
}
```

Key changes:
- Three independent useQuery calls instead of one
- Each section has its own loading, error, and refetch
- formatError() converts technical errors to user-friendly messages
- Legacy `loading` and `error` maintained for backward compatibility
  </action>
  <verify>Run `cd apps/web && pnpm build` to verify TypeScript compilation.</verify>
  <done>useDashboard hook provides independent error states for stats, appointments, and activity sections.</done>
</task>

<task type="auto">
  <name>Task 2: Update dashboard page for partial error states</name>
  <files>apps/web/src/app/dashboard/page.tsx</files>
  <action>
Update the dashboard page to use the new per-section error states:

1. Update the destructured values from useDashboard:

```typescript
const {
  stats,
  statsLoading,
  statsError,
  refetchStats,
  todayAppointments,
  appointmentsLoading,
  appointmentsError,
  refetchAppointments,
  recentActivity,
  activityLoading,
  activityError,
  refetchActivity,
  loading,
  refetch,
} = useDashboard(selectedLocationId);
```

2. Remove or modify the global error banner at the top. Replace the existing error display:

From:
```tsx
{error && (
  <div className="mb-6 p-4 bg-rose/10 border border-rose/20 rounded-xl flex items-center gap-3">
    ...
  </div>
)}
```

To: Remove this entirely (errors will show per-section instead).

3. Update the Stats Grid section to handle statsError:

Replace the stats grid loading/content with:
```tsx
{/* Stats Grid */}
<div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
  {statsError ? (
    // Stats error state
    <div className="col-span-full p-6 bg-rose/10 border border-rose/20 rounded-2xl">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <AlertCircle className="w-5 h-5 text-rose" />
          <div>
            <p className="font-medium text-charcoal dark:text-white">Could not load statistics</p>
            <p className="text-sm text-charcoal/60 dark:text-white/60">{statsError}</p>
          </div>
        </div>
        <button
          onClick={() => refetchStats()}
          className="px-4 py-2 bg-white border border-charcoal/20 rounded-lg text-sm font-medium hover:bg-charcoal/5"
        >
          Retry
        </button>
      </div>
    </div>
  ) : statsLoading ? (
    // Loading skeleton for stats
    [...Array(4)].map((_, i) => (
      <div
        key={i}
        className="bg-white dark:bg-sidebar rounded-2xl p-6 border border-border dark:border-white/10 shadow-soft animate-pulse"
      >
        <div className="flex items-start justify-between mb-4">
          <div className="w-12 h-12 bg-charcoal/10 dark:bg-white/10 rounded-xl" />
          <div className="w-12 h-4 bg-charcoal/10 dark:bg-white/10 rounded" />
        </div>
        <div className="w-20 h-8 bg-charcoal/10 dark:bg-white/10 rounded mb-2" />
        <div className="w-24 h-4 bg-charcoal/10 dark:bg-white/10 rounded" />
      </div>
    ))
  ) : (
    displayStats.map((stat) => {
      const Icon = stat.icon;
      return (
        // ... existing stat card JSX unchanged
      );
    })
  )}
</div>
```

4. Update Today's Schedule section to handle appointmentsError:

Modify the appointments section content:
```tsx
<div className="divide-y divide-border dark:divide-white/10">
  {appointmentsError ? (
    // Appointments error state
    <div className="p-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <AlertCircle className="w-5 h-5 text-rose" />
          <div>
            <p className="font-medium text-charcoal dark:text-white">Could not load today's appointments</p>
            <p className="text-sm text-charcoal/60 dark:text-white/60">{appointmentsError}</p>
          </div>
        </div>
        <button
          onClick={() => refetchAppointments()}
          className="px-4 py-2 bg-white border border-charcoal/20 rounded-lg text-sm font-medium hover:bg-charcoal/5"
        >
          Retry
        </button>
      </div>
    </div>
  ) : appointmentsLoading && todayAppointments.length === 0 ? (
    // Loading skeleton unchanged...
  ) : todayAppointments.length > 0 ? (
    // Appointments list unchanged...
  ) : (
    // Empty state unchanged...
  )}
</div>
```

5. Update Recent Activity section to handle activityError:

```tsx
<div className="p-4 space-y-4">
  {activityError ? (
    <div className="text-center py-6">
      <AlertCircle className="w-8 h-8 text-charcoal/30 dark:text-white/30 mx-auto mb-2" />
      <p className="text-sm text-charcoal/60 dark:text-white/60">{activityError}</p>
      <button
        onClick={() => refetchActivity()}
        className="mt-2 text-sm text-sage hover:text-sage-dark font-medium"
      >
        Retry
      </button>
    </div>
  ) : activityLoading && (!recentActivity || recentActivity.length === 0) ? (
    // Optional: Add activity loading skeleton
    [...Array(3)].map((_, i) => (
      <div key={i} className="flex gap-3 animate-pulse">
        <div className="w-2.5 h-2.5 rounded-full bg-charcoal/20 mt-1.5" />
        <div className="flex-1">
          <div className="w-24 h-4 bg-charcoal/10 rounded mb-1" />
          <div className="w-32 h-3 bg-charcoal/10 rounded" />
        </div>
      </div>
    ))
  ) : recentActivity && recentActivity.length > 0 ? (
    // Existing activity list...
  ) : (
    // Empty state unchanged...
  )}
</div>
```

6. Update the refresh button in the header to show loading state during any refresh:

```tsx
<button
  onClick={() => refetch()}
  className="p-2 text-charcoal/60 hover:text-charcoal dark:text-white/60 dark:hover:text-white"
  title="Refresh data"
>
  <RefreshCw className={`w-5 h-5 ${(statsLoading || appointmentsLoading) ? 'animate-spin' : ''}`} />
</button>
```
  </action>
  <verify>Run `cd apps/web && pnpm build` to verify TypeScript compilation.</verify>
  <done>Dashboard page displays partial error states per section with individual retry buttons.</done>
</task>

</tasks>

<verification>
1. Build web app: `cd apps/web && pnpm build` - should compile without errors
2. Start dev server: `cd apps/web && pnpm dev`
3. Manual verification:
   - Open dashboard page - all sections should load normally
   - In browser devtools, simulate network failure for one endpoint (e.g., block `/dashboard/stats`)
   - Verify stats section shows error with retry button
   - Verify appointments and activity sections still work
   - Click retry button - verify it retries just that section
4. Verify error messages are user-friendly (no raw HTTP errors or stack traces)
</verification>

<success_criteria>
- TypeScript compiles without errors
- Each dashboard section (stats, appointments, activity) has independent error handling
- Failed section shows error message with retry button
- Other sections continue to work when one fails
- Error messages are user-friendly, not technical
- Auto-refresh continues for working sections even when one section is errored
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-validation/07-03-SUMMARY.md`
</output>
