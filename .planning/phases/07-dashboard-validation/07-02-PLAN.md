---
phase: 07-dashboard-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/hooks/useDashboard.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard auto-refreshes every 60 seconds while page is open"
    - "Background refresh does not interrupt user interactions"
    - "Manual refresh button triggers immediate data reload"
  artifacts:
    - path: "apps/web/src/hooks/useDashboard.ts"
      provides: "Auto-refresh with TanStack Query refetchInterval"
      contains: "refetchInterval"
  key_links:
    - from: "apps/web/src/hooks/useDashboard.ts"
      to: "@tanstack/react-query"
      via: "useQuery hook"
      pattern: "useQuery"
---

<objective>
Add auto-refresh capability to dashboard using TanStack Query's built-in polling.

Purpose: Owners often leave the dashboard open throughout the day. Without auto-refresh, they see stale appointment counts and revenue numbers, potentially missing new bookings.

Output: Dashboard hook that automatically refreshes data every 60 seconds using TanStack Query.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dashboard-validation/07-CONTEXT.md
@.planning/phases/07-dashboard-validation/07-RESEARCH.md
@apps/web/src/hooks/useDashboard.ts
@apps/web/src/app/providers.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert useDashboard to TanStack Query with auto-refresh</name>
  <files>apps/web/src/hooks/useDashboard.ts</files>
  <action>
Rewrite the useDashboard hook to use TanStack Query's useQuery with auto-refresh:

1. Replace the current useState/useEffect pattern with useQuery. The file should become:

```typescript
'use client';

import { useQuery, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';

// Keep existing interface definitions (DashboardStats, ApiStatsResponse, etc.)
interface DashboardStats {
  todayAppointments: number;
  todayRevenue: number;
  monthRevenue: number;
  revenueChange: string;
  newClients: number;
  clientsChange: number;
}

interface ApiStatsResponse {
  revenue: { current: number; previous: number; change: number };
  appointments: { current: number; previous: number; change: number };
  newClients: { current: number; previous: number; change: number };
  totalClients: number;
  rating: { average: number | null; count: number };
}

interface TodayAppointment {
  id: string;
  startTime: string;
  endTime: string;
  status: string;
  client: { firstName: string; lastName: string };
  staff: { firstName: string; lastName: string };
  service: { name: string; color: string };
}

export interface RecentActivityItem {
  id: string;
  action: string;
  detail: string;
  time: string;
  type: 'booking' | 'payment' | 'client' | 'review' | 'cancellation';
}

interface RecentAppointment {
  id: string;
  status: string;
  createdAt: string;
  price: number;
  client: { firstName: string; lastName: string };
  service: { name: string };
}

// Helper to format relative time (keep existing implementation)
function formatRelativeTime(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins} min ago`;
  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
  if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
  return date.toLocaleDateString();
}

// Transform appointments to activity items (keep existing implementation)
function transformToActivity(appointments: RecentAppointment[]): RecentActivityItem[] {
  return appointments.map((apt) => {
    const clientName = `${apt.client.firstName} ${apt.client.lastName}`;

    if (apt.status === 'cancelled') {
      return {
        id: apt.id,
        action: 'Booking cancelled',
        detail: `${clientName} cancelled ${apt.service.name}`,
        time: formatRelativeTime(apt.createdAt),
        type: 'cancellation' as const,
      };
    }

    if (apt.status === 'completed') {
      return {
        id: apt.id,
        action: 'Payment received',
        detail: `$${apt.price} from ${clientName}`,
        time: formatRelativeTime(apt.createdAt),
        type: 'payment' as const,
      };
    }

    return {
      id: apt.id,
      action: 'New booking',
      detail: `${clientName} booked ${apt.service.name}`,
      time: formatRelativeTime(apt.createdAt),
      type: 'booking' as const,
    };
  });
}

// Fetch function for dashboard data
async function fetchDashboardData(locationId?: string | null) {
  const locationParam = locationId ? `?locationId=${locationId}` : '';

  const [statsRes, todayRes, recentRes] = await Promise.all([
    api.get<ApiStatsResponse>(`/dashboard/stats${locationParam}`),
    api.get<{ appointments: TodayAppointment[]; summary: { total: number } } | TodayAppointment[]>(
      `/dashboard/today${locationParam}`
    ),
    api.get<RecentAppointment[]>(`/dashboard/recent-activity${locationParam}`),
  ]);

  // Transform stats
  const apiData = statsRes.data;
  const todayData = todayRes.data;
  const todayCount = Array.isArray(todayData)
    ? todayData.length
    : (todayData?.summary?.total ?? todayData?.appointments?.length ?? 0);

  const stats: DashboardStats = {
    todayAppointments: todayCount,
    todayRevenue: 0, // Not tracked separately
    monthRevenue: apiData?.revenue?.current ?? 0,
    revenueChange: `${apiData?.revenue?.change ?? 0}%`,
    newClients: apiData?.newClients?.current ?? 0,
    clientsChange: apiData?.newClients?.change ?? 0,
  };

  // Transform appointments
  const appointments = Array.isArray(todayData)
    ? todayData
    : (todayData?.appointments ?? []);

  // Transform activity
  const recentData = Array.isArray(recentRes.data) ? recentRes.data : [];
  const activity = transformToActivity(recentData);

  return { stats, appointments, activity };
}

export function useDashboard(locationId?: string | null) {
  const queryClient = useQueryClient();

  const {
    data,
    error,
    isLoading,
    isFetching,
    refetch,
  } = useQuery({
    queryKey: ['dashboard', locationId],
    queryFn: () => fetchDashboardData(locationId),

    // Auto-refresh every 60 seconds
    refetchInterval: 60000,

    // Keep refreshing even when tab is in background
    refetchIntervalInBackground: true,

    // Refetch when window regains focus (if data is stale)
    refetchOnWindowFocus: true,

    // Data is considered stale after 30 seconds
    staleTime: 30000,

    // Keep data in cache for 5 minutes
    gcTime: 300000,

    // Retry failed requests 3 times with exponential backoff
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });

  return {
    stats: data?.stats ?? null,
    todayAppointments: data?.appointments ?? [],
    recentActivity: data?.activity ?? [],
    loading: isLoading,
    isFetching, // True during background refresh (can be used for subtle loading indicator)
    error: error instanceof Error ? error.message : error ? String(error) : null,
    refetch: () => refetch(),
  };
}
```

Key changes:
- Uses `useQuery` instead of manual useState/useEffect
- `refetchInterval: 60000` for 60-second auto-refresh
- `refetchIntervalInBackground: true` keeps refreshing in background tabs
- `staleTime: 30000` shows cached data immediately while fetching fresh
- `retry: 3` with exponential backoff for resilience
- Added `isFetching` to indicate background refresh (optional UI enhancement)

2. Ensure the queryKey includes locationId so queries are cached per location.
  </action>
  <verify>Run `cd apps/web && pnpm build` to verify TypeScript compilation succeeds.</verify>
  <done>useDashboard hook uses TanStack Query with 60-second auto-refresh, background refresh, stale-while-revalidate pattern, and retry logic.</done>
</task>

<task type="auto">
  <name>Task 2: Ensure QueryClientProvider is configured in providers</name>
  <files>apps/web/src/app/providers.tsx</files>
  <action>
Verify that QueryClientProvider is properly configured. Read the file first - if it already has QueryClientProvider with a QueryClient, no changes needed.

If QueryClientProvider is NOT present, add it:

```typescript
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useState } from 'react';
// ... other imports

export function Providers({ children }: { children: React.ReactNode }) {
  // Create QueryClient once per app instance
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        // Avoid aggressive refetching by default
        refetchOnWindowFocus: false,
        retry: 1,
      },
    },
  }));

  return (
    <QueryClientProvider client={queryClient}>
      {/* ... other providers ... */}
      {children}
    </QueryClientProvider>
  );
}
```

Most likely the provider already exists since TanStack Query is installed. Just verify it's there and working.
  </action>
  <verify>Run `cd apps/web && pnpm build` to confirm no provider errors.</verify>
  <done>QueryClientProvider is properly configured and wrapping the application.</done>
</task>

</tasks>

<verification>
1. Build web app: `cd apps/web && pnpm build` - should compile without errors
2. Start dev server: `cd apps/web && pnpm dev`
3. Manual verification:
   - Open dashboard page
   - Open browser devtools Network tab
   - Wait 60+ seconds
   - Confirm new requests to `/dashboard/stats`, `/dashboard/today`, `/dashboard/recent-activity` appear automatically
   - Click manual refresh button - confirm immediate request
4. Verify that navigating away and back does not cause unnecessary refetches (stale data shows immediately)
</verification>

<success_criteria>
- TypeScript compiles without errors
- Dashboard fetches fresh data every 60 seconds automatically
- Manual refresh button still works (triggers immediate refetch)
- No visual flicker during background refresh (stale data remains visible)
- Retry logic handles transient network errors gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-validation/07-02-SUMMARY.md`
</output>
