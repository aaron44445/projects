---
phase: 14-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - apps/api/src/workers/notification-worker.ts
  - apps/api/src/index.ts
  - apps/api/src/routes/appointments.ts
autonomous: true

must_haves:
  truths:
    - "Booking confirmation API returns 201 before email/SMS is sent"
    - "Notification job is inserted into database on booking creation"
    - "Background worker polls and processes notification jobs every 5 seconds"
    - "Failed notifications are retried up to 3 times"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "NotificationJob model definition"
      contains: "model NotificationJob"
    - path: "apps/api/src/workers/notification-worker.ts"
      provides: "Background polling worker for notification jobs"
      exports: ["startNotificationWorker"]
    - path: "apps/api/src/routes/appointments.ts"
      provides: "Async notification enqueueing on booking"
      contains: "notificationJob.create"
  key_links:
    - from: "apps/api/src/routes/appointments.ts"
      to: "prisma.notificationJob.create"
      via: "job enqueue after appointment creation"
      pattern: "notificationJob\\.create"
    - from: "apps/api/src/workers/notification-worker.ts"
      to: "sendNotification"
      via: "worker imports and calls notification service"
      pattern: "sendNotification"
    - from: "apps/api/src/index.ts"
      to: "startNotificationWorker"
      via: "worker started on server boot"
      pattern: "startNotificationWorker"
---

<objective>
Implement async notification queue using database job table with polling worker.

Purpose: Booking confirmation API currently blocks on email/SMS sending (2-5 seconds). By enqueueing notifications and processing them asynchronously, API response time drops to <200ms.

Output: NotificationJob Prisma model, background worker that polls every 5 seconds, appointments route that enqueues instead of awaiting notifications.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-performance-optimization/14-CONTEXT.md
@.planning/phases/14-performance-optimization/14-RESEARCH.md

# Current implementation files
@packages/database/prisma/schema.prisma
@apps/api/src/routes/appointments.ts
@apps/api/src/services/notifications.ts
@apps/api/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NotificationJob model to Prisma schema</name>
  <files>packages/database/prisma/schema.prisma</files>
  <action>
Add NotificationJob model at the end of schema.prisma (before the last closing):

```prisma
model NotificationJob {
  id            String   @id @default(uuid())
  salonId       String   @map("salon_id")
  clientId      String   @map("client_id")
  appointmentId String?  @map("appointment_id")
  type          String   // 'booking_confirmation', 'reminder_24h', 'reminder_2h', 'cancellation'
  payload       String   // JSON stringified notification data
  status        String   @default("pending") // 'pending', 'processing', 'completed', 'failed'
  attempts      Int      @default(0)
  maxAttempts   Int      @default(3) @map("max_attempts")
  error         String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  processedAt   DateTime? @map("processed_at")

  @@index([status, createdAt])
  @@index([status, attempts])
  @@map("notification_jobs")
}
```

Then run `npx prisma db push` from packages/database directory to apply the schema change.
  </action>
  <verify>
Run `npx prisma db push --skip-generate` from packages/database directory - should succeed without errors.
Verify the notification_jobs table exists by checking schema output.
  </verify>
  <done>NotificationJob model exists in schema.prisma and notification_jobs table is created in database.</done>
</task>

<task type="auto">
  <name>Task 2: Create notification worker with polling loop</name>
  <files>apps/api/src/workers/notification-worker.ts</files>
  <action>
Create new file apps/api/src/workers/notification-worker.ts:

```typescript
import { prisma } from '@peacase/database';
import { sendNotification, NotificationPayload } from '../services/notifications.js';

const POLL_INTERVAL_MS = 5000; // 5 seconds
const BATCH_SIZE = 10;
const STALE_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Process pending notification jobs from the database queue.
 * Uses raw SQL with FOR UPDATE SKIP LOCKED for safe concurrent processing.
 */
async function processJobs(): Promise<void> {
  try {
    // First, recover any stale "processing" jobs (crashed worker scenario)
    await recoverStaleJobs();

    // Fetch pending jobs using raw SQL for SKIP LOCKED support
    // Note: Prisma doesn't support FOR UPDATE SKIP LOCKED natively
    const jobs = await prisma.$queryRaw<Array<{
      id: string;
      salon_id: string;
      client_id: string;
      appointment_id: string | null;
      type: string;
      payload: string;
      status: string;
      attempts: number;
      max_attempts: number;
    }>>`
      SELECT id, salon_id, client_id, appointment_id, type, payload, status, attempts, max_attempts
      FROM notification_jobs
      WHERE status = 'pending'
      AND attempts < max_attempts
      ORDER BY created_at ASC
      LIMIT ${BATCH_SIZE}
      FOR UPDATE SKIP LOCKED
    `;

    if (jobs.length === 0) {
      return; // No work to do
    }

    console.log(`[WORKER] Processing ${jobs.length} notification job(s)`);

    for (const job of jobs) {
      await processJob(job);
    }
  } catch (error) {
    console.error('[WORKER] Error in processJobs:', error);
  }
}

/**
 * Process a single notification job
 */
async function processJob(job: {
  id: string;
  salon_id: string;
  client_id: string;
  appointment_id: string | null;
  type: string;
  payload: string;
  attempts: number;
  max_attempts: number;
}): Promise<void> {
  try {
    // Mark as processing
    await prisma.notificationJob.update({
      where: { id: job.id },
      data: {
        status: 'processing',
        attempts: job.attempts + 1,
      },
    });

    // Parse payload and send notification
    const payload: NotificationPayload = JSON.parse(job.payload);

    // Ensure payload has required fields
    const notificationPayload: NotificationPayload = {
      salonId: job.salon_id,
      clientId: job.client_id,
      appointmentId: job.appointment_id || undefined,
      type: payload.type || job.type as NotificationPayload['type'],
      channels: payload.channels || ['email', 'sms'],
      data: payload.data,
    };

    const result = await sendNotification(notificationPayload);

    if (result.status === 'sent') {
      // Mark complete
      await prisma.notificationJob.update({
        where: { id: job.id },
        data: {
          status: 'completed',
          processedAt: new Date(),
        },
      });
      console.log(`[WORKER] Job ${job.id} completed successfully`);
    } else {
      // Notification service returned failure
      const isFinalAttempt = job.attempts + 1 >= job.max_attempts;
      await prisma.notificationJob.update({
        where: { id: job.id },
        data: {
          status: isFinalAttempt ? 'failed' : 'pending',
          error: 'Notification service returned failed status',
        },
      });
      console.log(`[WORKER] Job ${job.id} failed (attempt ${job.attempts + 1}/${job.max_attempts})`);
    }
  } catch (error: unknown) {
    console.error(`[WORKER] Error processing job ${job.id}:`, error);

    const isFinalAttempt = job.attempts + 1 >= job.max_attempts;
    const errorMessage = error instanceof Error ? error.message : String(error);

    await prisma.notificationJob.update({
      where: { id: job.id },
      data: {
        status: isFinalAttempt ? 'failed' : 'pending',
        error: errorMessage,
      },
    });
  }
}

/**
 * Recover jobs that are stuck in "processing" status (crashed worker)
 */
async function recoverStaleJobs(): Promise<void> {
  const staleThreshold = new Date(Date.now() - STALE_TIMEOUT_MS);

  const result = await prisma.notificationJob.updateMany({
    where: {
      status: 'processing',
      updatedAt: { lt: staleThreshold },
    },
    data: {
      status: 'pending',
    },
  });

  if (result.count > 0) {
    console.log(`[WORKER] Recovered ${result.count} stale job(s)`);
  }
}

/**
 * Start the notification worker polling loop.
 * Should be called once when the server starts.
 */
export function startNotificationWorker(): void {
  console.log('[WORKER] Notification worker started (poll interval: 5s)');

  // Initial poll
  processJobs();

  // Continuous polling
  setInterval(() => {
    processJobs();
  }, POLL_INTERVAL_MS);
}

/**
 * Clean up old completed jobs (call this from a daily cron)
 */
export async function cleanupOldJobs(daysToKeep = 7): Promise<number> {
  const cutoffDate = new Date(Date.now() - daysToKeep * 24 * 60 * 60 * 1000);

  const result = await prisma.notificationJob.deleteMany({
    where: {
      status: 'completed',
      processedAt: { lt: cutoffDate },
    },
  });

  console.log(`[WORKER] Cleaned up ${result.count} old completed job(s)`);
  return result.count;
}
```

Key design decisions:
- Uses raw SQL for FOR UPDATE SKIP LOCKED (Prisma doesn't support this natively)
- Polls every 5 seconds (per CONTEXT.md decision)
- Recovers stale jobs stuck in "processing" (handles worker crashes)
- 3 max attempts with automatic retry
- Includes cleanup function for old jobs
  </action>
  <verify>
Verify file exists and has no TypeScript errors:
```bash
cd apps/api && npx tsc --noEmit src/workers/notification-worker.ts
```
  </verify>
  <done>notification-worker.ts exists with startNotificationWorker function exported.</done>
</task>

<task type="auto">
  <name>Task 3: Update appointments route to enqueue instead of await notifications</name>
  <files>apps/api/src/routes/appointments.ts, apps/api/src/index.ts</files>
  <action>
1. In apps/api/src/routes/appointments.ts, update the POST / handler:

Replace the current synchronous email/SMS sending (lines ~403-434):
```typescript
// Send email confirmation
if (client?.email && client?.optedInReminders) {
  await sendEmail({...});
}

// Send SMS confirmation
if (client?.phone && client?.optedInReminders) {
  await sendSms({...});
}
```

With async job enqueueing:
```typescript
// Enqueue notification job (async - don't await the actual send)
if (client?.optedInReminders && (client?.email || client?.phone)) {
  await prisma.notificationJob.create({
    data: {
      salonId: req.user!.salonId,
      clientId: appointment.clientId,
      appointmentId: appointment.id,
      type: 'booking_confirmation',
      payload: JSON.stringify({
        type: 'booking_confirmation',
        channels: [
          ...(client.email ? ['email'] : []),
          ...(client.phone ? ['sms'] : []),
        ],
        data: {
          clientName: client.firstName,
          clientEmail: client.email,
          clientPhone: client.phone,
          serviceName: service.name,
          staffName: `${staff?.firstName} ${staff?.lastName}`,
          dateTime: formattedDateTime,
          salonName: salon?.name || '',
          salonAddress: salon?.address || '',
          startTime: appointment.startTime,
          endTime: appointmentEndTime,
          salonTimezone: salon?.timezone,
          salonEmail: salon?.email,
        },
      }),
      status: 'pending',
      attempts: 0,
      maxAttempts: 3,
    },
  });
}
```

This replaces the direct sendEmail/sendSms calls with a single job enqueue. The background worker will process it.

2. In apps/api/src/index.ts, start the notification worker:

Add import at the top (around line 48, after other imports):
```typescript
import { startNotificationWorker } from './workers/notification-worker.js';
```

Add worker start after cron jobs (inside the app.listen callback, after line 235):
```typescript
// Start cron jobs after server is running
startCronJobs();

// Start notification worker for async job processing
startNotificationWorker();
```

Note: Keep the existing sendEmail import in appointments.ts (used elsewhere), but remove the sendSms import if it's only used in the POST handler.
  </action>
  <verify>
1. Start the API server locally and create a test booking
2. Verify:
   - API returns 201 immediately (< 500ms)
   - NotificationJob record created with status 'pending'
   - Worker log shows "[WORKER] Processing 1 notification job(s)"
   - Job status changes to 'completed' after processing

Manual test command:
```bash
curl -X POST http://localhost:4000/api/v1/appointments \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"clientId":"...", "staffId":"...", "serviceId":"...", "startTime":"..."}'
```
  </verify>
  <done>
POST /api/v1/appointments returns 201 before email/SMS is sent.
Notification job is created in notification_jobs table.
Worker processes job in background within 5 seconds.
  </done>
</task>

</tasks>

<verification>
1. Schema: `npx prisma db push` succeeds, notification_jobs table exists
2. Worker: Server starts without errors, "[WORKER] Notification worker started" appears in logs
3. Booking: Create appointment via API, verify job appears in notification_jobs table with status 'pending'
4. Processing: Within 5 seconds, job status changes to 'completed' and email/SMS are sent
5. Error handling: Manually fail a notification (disconnect email service), verify job retries up to 3 times then marks as 'failed'
</verification>

<success_criteria>
- API response time for POST /appointments is < 500ms (previously 2-5s)
- NotificationJob records are created on booking
- Background worker processes jobs within 5-10 seconds
- Failed notifications are retried up to 3 times
- Stale jobs (stuck in 'processing' > 5 min) are recovered automatically
</success_criteria>

<output>
After completion, create `.planning/phases/14-performance-optimization/14-01-SUMMARY.md`
</output>
