---
phase: 14-performance-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/routes/dashboard.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard stats endpoint makes 2-3 database round-trips instead of 8+"
    - "VIP client count is returned from database COUNT query"
    - "All independent queries run in parallel via Promise.all"
    - "API response includes vipClients field"
  artifacts:
    - path: "apps/api/src/routes/dashboard.ts"
      provides: "Consolidated parallel queries for dashboard stats"
      contains: "Promise.all"
  key_links:
    - from: "apps/api/src/routes/dashboard.ts"
      to: "prisma.client.count"
      via: "VIP client count query"
      pattern: "tags.*has.*VIP"
---

<objective>
Consolidate dashboard queries from 8+ sequential round-trips to 2-3 parallel queries, and add VIP client count using database COUNT.

Purpose: Dashboard currently makes multiple sequential database queries (8+ round-trips), causing 500-1000ms load times. By consolidating into parallel queries with Promise.all and adding a database-level VIP count, response time drops to ~50-100ms.

Output: Optimized dashboard.ts /stats endpoint with all queries running in parallel, including VIP client count.
</objective>

<execution_context>
@C:\Users\aaron\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aaron\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-performance-optimization/14-CONTEXT.md
@.planning/phases/14-performance-optimization/14-RESEARCH.md

# Current implementation
@apps/api/src/routes/dashboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consolidate dashboard stats queries with Promise.all</name>
  <files>apps/api/src/routes/dashboard.ts</files>
  <action>
Refactor the /stats endpoint to run ALL queries in parallel using a single Promise.all.

Current code has this pattern (sequential with some parallel):
1. currentMonthPayments aggregate (await)
2. lastMonthPayments aggregate (await)
3. [thisMonthAppointments, lastMonthAppointments] via Promise.all
4. [thisMonthClients, lastMonthClients] via Promise.all
5. totalClients count (await)
6. avgRating aggregate (await)
7. salon findUnique (await)

Replace with a SINGLE Promise.all containing ALL queries:

```typescript
router.get('/stats', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const salonId = req.user!.salonId;
  const { locationId } = req.query;
  const locationFilter = locationId ? { locationId: locationId as string } : {};

  // Get date ranges
  const now = new Date();
  const startOfThisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  const startOfLastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
  const endOfLastMonth = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);

  // Run ALL queries in parallel (single Promise.all instead of 8+ sequential queries)
  const [
    currentMonthPayments,
    lastMonthPayments,
    thisMonthAppointments,
    lastMonthAppointments,
    thisMonthClients,
    lastMonthClients,
    totalClients,
    vipClients,
    avgRating,
    salon,
  ] = await Promise.all([
    // Current month payments
    prisma.payment.aggregate({
      where: {
        salonId,
        ...locationFilter,
        status: 'completed',
        createdAt: { gte: startOfThisMonth },
      },
      _sum: { totalAmount: true, refundAmount: true },
    }),

    // Last month payments
    prisma.payment.aggregate({
      where: {
        salonId,
        ...locationFilter,
        status: 'completed',
        createdAt: { gte: startOfLastMonth, lte: endOfLastMonth },
      },
      _sum: { totalAmount: true, refundAmount: true },
    }),

    // This month appointments
    prisma.appointment.count({
      where: {
        salonId,
        ...locationFilter,
        startTime: { gte: startOfThisMonth },
        status: { notIn: ['cancelled', 'no_show'] },
      },
    }),

    // Last month appointments
    prisma.appointment.count({
      where: {
        salonId,
        ...locationFilter,
        startTime: { gte: startOfLastMonth, lte: endOfLastMonth },
        status: { notIn: ['cancelled', 'no_show'] },
      },
    }),

    // This month new clients
    prisma.client.count({
      where: {
        salonId,
        createdAt: { gte: startOfThisMonth },
      },
    }),

    // Last month new clients
    prisma.client.count({
      where: {
        salonId,
        createdAt: { gte: startOfLastMonth, lte: endOfLastMonth },
      },
    }),

    // Total active clients
    prisma.client.count({
      where: { salonId, isActive: true },
    }),

    // VIP clients count (NEW - PERF-03 requirement)
    // Uses database-level filtering instead of client-side
    prisma.client.count({
      where: {
        salonId,
        isActive: true,
        // Note: If tags is stored as JSON array in your schema,
        // you may need raw SQL. For now assuming it can be queried.
        // If Client model doesn't have tags field, skip this query
        // and return 0 for vipClients.
      },
    }),

    // Average rating
    prisma.review.aggregate({
      where: { salonId, isApproved: true },
      _avg: { rating: true },
      _count: { rating: true },
    }),

    // Salon timezone
    prisma.salon.findUnique({
      where: { id: salonId },
      select: { timezone: true },
    }),
  ]);

  // Calculate NET revenue
  const currentGross = currentMonthPayments._sum.totalAmount || 0;
  const currentRefunds = currentMonthPayments._sum.refundAmount || 0;
  const currentRevenue = currentGross - currentRefunds;

  const lastGross = lastMonthPayments._sum.totalAmount || 0;
  const lastRefunds = lastMonthPayments._sum.refundAmount || 0;
  const lastRevenue = lastGross - lastRefunds;

  // Calculate percentage changes
  const revenueChange = lastRevenue > 0
    ? Math.round(((currentRevenue - lastRevenue) / lastRevenue) * 100)
    : currentRevenue > 0 ? 100 : 0;

  const appointmentChange = lastMonthAppointments > 0
    ? Math.round(((thisMonthAppointments - lastMonthAppointments) / lastMonthAppointments) * 100)
    : thisMonthAppointments > 0 ? 100 : 0;

  const clientChange = lastMonthClients > 0
    ? Math.round(((thisMonthClients - lastMonthClients) / lastMonthClients) * 100)
    : thisMonthClients > 0 ? 100 : 0;

  const salonTz = salon?.timezone || 'UTC';

  res.json({
    success: true,
    data: {
      revenue: {
        current: currentRevenue,
        previous: lastRevenue,
        change: revenueChange,
      },
      appointments: {
        current: thisMonthAppointments,
        previous: lastMonthAppointments,
        change: appointmentChange,
      },
      newClients: {
        current: thisMonthClients,
        previous: lastMonthClients,
        change: clientChange,
      },
      totalClients,
      vipClients, // NEW field for PERF-03
      rating: {
        average: avgRating._avg.rating ? Math.round(avgRating._avg.rating * 10) / 10 : null,
        count: avgRating._count.rating,
      },
      timezone: salonTz,
    },
  });
}));
```

IMPORTANT: Check the Client model in schema.prisma for a 'tags' field. If it doesn't exist:
- For now, set vipClients to 0 or skip the query
- Note in SUMMARY.md that VIP tagging requires schema addition

The key optimization is moving from sequential awaits to a single Promise.all.
  </action>
  <verify>
1. Check TypeScript compiles: `cd apps/api && npx tsc --noEmit`
2. Test the endpoint manually:
```bash
curl -X GET http://localhost:4000/api/v1/dashboard/stats \
  -H "Authorization: Bearer $TOKEN"
```
3. Verify response includes `vipClients` field
4. Measure response time (should be < 200ms)
  </verify>
  <done>
Dashboard /stats endpoint uses single Promise.all for all 10 queries.
Response includes vipClients field.
Response time is < 200ms (down from 500-1000ms).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update frontend interface for vipClients</name>
  <files>apps/web/src/hooks/useDashboard.ts</files>
  <action>
Update the ApiStatsResponse interface to include vipClients:

Find the interface definition (around line 17-24):
```typescript
interface ApiStatsResponse {
  revenue: { current: number; previous: number; change: number };
  appointments: { current: number; previous: number; change: number };
  newClients: { current: number; previous: number; change: number };
  totalClients: number;
  rating: { average: number | null; count: number };
  timezone: string;
}
```

Add vipClients:
```typescript
interface ApiStatsResponse {
  revenue: { current: number; previous: number; change: number };
  appointments: { current: number; previous: number; change: number };
  newClients: { current: number; previous: number; change: number };
  totalClients: number;
  vipClients: number; // NEW
  rating: { average: number | null; count: number };
  timezone: string;
}
```

The vipClients value is now available in the stats response for dashboard UI to display if needed.

Note: This task only adds the type - the UI can optionally display it later. The important thing is the backend returns it via database COUNT rather than client-side filtering.
  </action>
  <verify>
Check TypeScript compiles: `cd apps/web && npx tsc --noEmit`
  </verify>
  <done>ApiStatsResponse interface includes vipClients field.</done>
</task>

</tasks>

<verification>
1. API endpoint returns in < 200ms (use browser devtools Network tab or curl timing)
2. Response JSON includes `vipClients` field
3. All stats values are correct (compare with current production values)
4. TypeScript compiles without errors in both apps/api and apps/web
</verification>

<success_criteria>
- Dashboard /stats endpoint makes 1 database round-trip (parallel queries via Promise.all) instead of 8+ sequential
- vipClients is returned in the API response
- Response time is < 200ms (down from 500-1000ms)
- No breaking changes to existing stats structure
</success_criteria>

<output>
After completion, create `.planning/phases/14-performance-optimization/14-02-SUMMARY.md`
</output>
